[{"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/index.js":"1","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/App.js":"2","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/reportWebVitals.js":"3","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/Navbar.js":"4","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/MouseDraw.js":"5","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/LeftPanel.js":"6","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/RightPanel.js":"7","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/InfoTooltip.js":"8","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/d3-rendering/cloudFunctions.js":"9","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/d3-rendering/projectionManipulationFunctions.js":"10","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/index.js":"11","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/reportWebVitals.js":"12","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/App.js":"13","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/LeftPanel.js":"14","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/MouseDraw.js":"15","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/Navbar.js":"16","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/InfoTooltip.js":"17","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/RightPanel.js":"18","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/d3-rendering/projectionManipulationFunctions.js":"19","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/d3-rendering/cloudFunctions.js":"20","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/index.js":"21","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/App.js":"22","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/reportWebVitals.js":"23","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/Navbar.js":"24","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/MouseDraw.js":"25","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/LeftPanel.js":"26","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/InfoTooltip.js":"27","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/RightPanel.js":"28","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/d3-rendering/cloudFunctions.js":"29","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/d3-rendering/projectionManipulationFunctions.js":"30"},{"size":535,"mtime":1680908897832,"results":"31","hashOfConfig":"32"},{"size":603,"mtime":1681261158685,"results":"33","hashOfConfig":"32"},{"size":362,"mtime":1680908897832,"results":"34","hashOfConfig":"32"},{"size":295,"mtime":1681260955838,"results":"35","hashOfConfig":"32"},{"size":8426,"mtime":1681269184454,"results":"36","hashOfConfig":"32"},{"size":18690,"mtime":1681262436604,"results":"37","hashOfConfig":"32"},{"size":11104,"mtime":1681309248676,"results":"38","hashOfConfig":"32"},{"size":1141,"mtime":1680908897830,"results":"39","hashOfConfig":"32"},{"size":3367,"mtime":1681310076127,"results":"40","hashOfConfig":"32"},{"size":17532,"mtime":1681273036914,"results":"41","hashOfConfig":"32"},{"size":535,"mtime":1680908897832,"results":"42","hashOfConfig":"43"},{"size":362,"mtime":1680908897832,"results":"44","hashOfConfig":"43"},{"size":603,"mtime":1681261158685,"results":"45","hashOfConfig":"43"},{"size":19156,"mtime":1681487377045,"results":"46","hashOfConfig":"43"},{"size":7537,"mtime":1681425572208,"results":"47","hashOfConfig":"43"},{"size":295,"mtime":1681260955838,"results":"48","hashOfConfig":"43"},{"size":1141,"mtime":1680908897830,"results":"49","hashOfConfig":"43"},{"size":11209,"mtime":1681437366789,"results":"50","hashOfConfig":"43"},{"size":17532,"mtime":1681434054876,"results":"51","hashOfConfig":"43"},{"size":3367,"mtime":1681310076127,"results":"52","hashOfConfig":"43"},{"size":535,"mtime":1681488762302,"results":"53","hashOfConfig":"54"},{"size":603,"mtime":1681488762287,"results":"55","hashOfConfig":"54"},{"size":362,"mtime":1681488762303,"results":"56","hashOfConfig":"54"},{"size":295,"mtime":1681488762289,"results":"57","hashOfConfig":"54"},{"size":7554,"mtime":1681488859125,"results":"58","hashOfConfig":"54"},{"size":19173,"mtime":1681488852229,"results":"59","hashOfConfig":"54"},{"size":1141,"mtime":1681488762288,"results":"60","hashOfConfig":"54"},{"size":11226,"mtime":1681488866275,"results":"61","hashOfConfig":"54"},{"size":3367,"mtime":1681488762291,"results":"62","hashOfConfig":"54"},{"size":17532,"mtime":1681488878986,"results":"63","hashOfConfig":"54"},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1u2jn2j",{"filePath":"67","messages":"68","suppressedMessages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","suppressedMessages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","suppressedMessages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80"},{"filePath":"81","messages":"82","suppressedMessages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84"},{"filePath":"85","messages":"86","suppressedMessages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88"},{"filePath":"89","messages":"90","suppressedMessages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"92","messages":"93","suppressedMessages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"95","messages":"96","suppressedMessages":"97","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"98"},{"filePath":"99","messages":"100","suppressedMessages":"101","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"8cxtss",{"filePath":"102","messages":"103","suppressedMessages":"104","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","suppressedMessages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"108","messages":"109","suppressedMessages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114"},{"filePath":"115","messages":"116","suppressedMessages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"118","messages":"119","suppressedMessages":"120","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"121","messages":"122","suppressedMessages":"123","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124"},{"filePath":"125","messages":"126","suppressedMessages":"127","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128"},{"filePath":"129","messages":"130","suppressedMessages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"132"},{"filePath":"133","messages":"134","suppressedMessages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"9gvat7",{"filePath":"136","messages":"137","suppressedMessages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"139","messages":"140","suppressedMessages":"141","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"142","messages":"143","suppressedMessages":"144","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"145","messages":"146","suppressedMessages":"147","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"148","messages":"149","suppressedMessages":"150","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"151","messages":"152","suppressedMessages":"153","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"154","messages":"155","suppressedMessages":"156","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"157","messages":"158","suppressedMessages":"159","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"160","messages":"161","suppressedMessages":"162","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/index.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/App.js",["163"],[],"import \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./App.css\";\n\nimport { MouseDraw } from \"./components/MouseDraw.js\";\nimport { LeftPanel } from \"./components/LeftPanel.js\";\n// import classNames from \"classnames/bind\";\nimport { Header } from \"./components/Navbar.js\";\n\nfunction App() {\n  let width = window.innerWidth - 720;\n  let height = window.innerHeight - 50;\n  return (\n    <div className=\"App\">\n      <div className=\"body\">\n        <LeftPanel width={width} height={height} />\n        <MouseDraw x={0} y={0} width={width} height={height} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/reportWebVitals.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/Navbar.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/MouseDraw.js",["164","165","166"],[],"import React, {\n  useMemo,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n} from \"react\";\nimport * as d3 from \"d3\";\nimport {\n  checkPoints,\n  autocheckPoints,\n  reset,\n  drawToolTip,\n  eraseToolTip,\n} from \"../d3-rendering/projectionManipulationFunctions.js\";\nimport \"../App.css\";\nimport { RightPanel } from \"./RightPanel.js\";\nimport axios from \"axios\";\nimport { drawClouds } from \"../d3-rendering/cloudFunctions.js\";\n\nconst localDevURL = \"http://127.0.0.1:8000/\";\nconst DEFAULT_PROMPT =\n  \"What is the common theme between the selected sentences?\";\n\n// Line element\nconst Line = ({ points, drawing }) => {\n  const line = useMemo(() => {\n    return d3\n      .line()\n      .x((d) => d.x)\n      .y((d) => d.y);\n  }, []);\n\n  var dataCopy = points;\n  // console.log(points);\n\n  // Closes loop if done drawing\n  if (dataCopy.length > 0 && !drawing) {\n    dataCopy = [...dataCopy, points[0]];\n  }\n\n  return (\n    <path\n      id=\"lasso\"\n      d={line(dataCopy)}\n      style={{\n        stroke: \"blue\",\n        strokeWidth: 2,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        fill: \"rgba(0,100,255,0.05)\",\n      }}\n    />\n  );\n};\n\n\n\nexport const MouseDraw = ({ x, y, width, height }) => {\n  // States and state setters\n  const [drawing, setDrawing] = useState(false);\n  const [currentLine, setCurrentLine] = useState({ points: [] });\n  const [selectedPoints, setSelectedPoints] = useState([]);\n  const [topWords, setTopWords] = useState({\n    positiveWord: null,\n    negativeWord: null,\n  });\n  const [wordsLoading, setWordsLoading] = useState(false);\n  const [keyVal, setKeyVal] = useState(\"\");\n  const [test_text, setTestText] = useState(\"\");\n\n  const [prompt, setPrompt] = useState(DEFAULT_PROMPT);\n  const [explanation, setExplanation] = useState(\n    \"Select points to see an explanation\"\n  );\n  const [autoClusterLabel, setautoClusterLabel] =  useState(false);\n\n\n\n  const drawingAreaRef = useRef();\n\n  // When the mouse moves, adds the newest point to the list of points for the current line\n  const mouseMove = useCallback(\n    function (event) {\n      const [x, y] = d3.pointer(event);\n      if (drawing) {\n        setCurrentLine((line) => ({\n          ...line,\n          points: [...line.points, { x, y }],\n        }));\n      }\n    },\n    [drawing]\n  );\n\n  // Creates a new line and starts drawing\n  function enableDrawing() {\n    reset();\n    setCurrentLine({ points: [] });\n    setSelectedPoints([]);\n    setDrawing(true);\n    setTopWords({ positiveWord: null, negativeWord: null });\n  }\n\n  // Adds the new line to the array of lines, stops drawing on mouseup\n  function disableDrawing() {\n    setDrawing(false);\n    // Check if points are in path on mouseup\n    let { brushedPoints, categorizedPoints, selectedLabels } = checkPoints();\n\n    // Send brushed points to right panel\n    setSelectedPoints(brushedPoints);\n    \n    if (brushedPoints.length > 0) {\n      // Send categorized points to back for linear classification\n      setWordsLoading(true);\n      axios\n        .post(localDevURL + \"categorize-data\", {\n          data: JSON.stringify(categorizedPoints),\n        })\n        .then((response) => {\n          console.log(\"Categorized!\", response.data.data);\n          let newTopWords = drawClouds(response.data.data);\n          setWordsLoading(false);\n          setTopWords(newTopWords);\n          // TODO: do things with response\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n      axios\n        .post(localDevURL + \"GPT-explanation\", {\n          apiKey: keyVal,\n          selectedLabels: JSON.stringify([prompt, ...selectedLabels]),\n        })\n        .then((response) => {\n          console.log(response)\n          setExplanation(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }\n\n  function getExplanationClusterLabel(){\n    console.log(autoClusterLabel)\n    setDrawing(false);\n    // Check if points are in path on mouseup\n    let { brushedPoints, categorizedPoints, selectedLabels } = autocheckPoints(autoClusterLabel);\n\n    // Send brushed points to right panel\n    setSelectedPoints(brushedPoints);\n    \n    if (brushedPoints.length > 0) {\n      // Send categorized points to back for linear classification\n      setWordsLoading(true);\n      axios\n        .post(localDevURL + \"categorize-data\", {\n          data: JSON.stringify(categorizedPoints),\n        })\n        .then((response) => {\n          console.log(\"Categorized!\", response.data.data);\n          let newTopWords = drawClouds(response.data.data);\n          setWordsLoading(false);\n          setTopWords(newTopWords);\n          // TODO: do things with response\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n      axios\n        .post(localDevURL + \"GPT-explanation\", {\n          apiKey: keyVal,\n          selectedLabels: JSON.stringify([prompt, ...selectedLabels]),\n        })\n        .then((response) => {\n          console.log(response)\n          setExplanation(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }\n\n \n\n  function handleMouseOver(e) {\n    if (!drawing && e.target.tagName.toLowerCase() === \"circle\") {\n      drawToolTip(e.target.id, width);\n    }\n  }\n\n  function handleMouseOut(e) {\n    if (!drawing && e.target.tagName.toLowerCase() === \"circle\") {\n      eraseToolTip(e.target.id);\n    }\n  }\n\n  // Called mouseMove on mouseover of the drawing area\n  useEffect(() => {\n    const area = d3.select(drawingAreaRef.current);\n    area.on(\"mousemove\", mouseMove);\n    return () => area.on(\"mousemove\", null);\n  }, [mouseMove]);\n\n\n// request new explanation when prompt changes\nuseEffect(() => {\n  axios\n    .post(localDevURL + \"test-projection\", {\n      text: test_text,\n    })\n    .then((response) => {\n      console.log(response);\n      // SVG\n      var svg = d3.select(\"#containerSVG\")\n      svg\n        .append(\"g\")\n        .selectAll(\"circle\")\n        .data(response.data.data)\n        .enter()\n        .append(\"circle\")\n        .attr(\"r\", 50)\n        .attr(\"opacity\", 1)\n        .attr(\"id\", 'test-point')\n        .attr(\"cx\", (d) => {\n          let centerX = x(+d[0]);\n          return centerX;\n        })\n        .attr(\"cy\", (d) => {\n          let centerY = y(+d[1]);\n          return centerY;\n        })\n        .attr(\"fill\", \"green\")\n\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n}, [prompt]);\n\n  \n\n  // request new explanation when prompt changes\n  useEffect(() => {\n    console.log(\"KEY:\", keyVal);\n    console.log(\"changedPrompt:\", prompt);\n    let { brushedPoints, categorizedPoints, selectedLabels } = checkPoints();\n    if (brushedPoints.length > 0) {\n      axios\n        .post(localDevURL + \"GPT-explanation\", {\n          apiKey: keyVal,\n          selectedLabels: JSON.stringify([prompt, ...selectedLabels]),\n        })\n        .then((response) => {\n          console.log(response);\n          setExplanation(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }, [prompt]);\n\n  // request new explanation when label changes\n   useEffect(() => {\n  }, [autoClusterLabel]);\n\n\n\n  return (\n    <div className=\"body\">\n      <svg\n        id=\"containerSVG\"\n        width={width}\n        height={height}\n        onMouseDown={enableDrawing}\n        onMouseUp={disableDrawing}\n        onMouseOver={(e) => {\n          handleMouseOver(e);\n        }}\n        onMouseOut={(e) => {\n          handleMouseOut(e);\n        }}\n      >\n        <g ref={drawingAreaRef}>\n          {/* Drawing background, gives \"g\" its size */}\n          <rect\n            x={0}\n            y={0}\n            width={width}\n            height={height}\n            style={{ fill: \"white\" }}\n          />\n          {/* Renders lines */}\n          <Line points={currentLine.points} drawing={drawing} />\n        </g>\n      </svg>\n      <RightPanel\n        selectedPoints={selectedPoints}\n        pathPoints={currentLine.points}\n        topWords={topWords}\n        wordsLoading={wordsLoading}\n        prompt={prompt}\n        setPrompt={setPrompt}\n        explanation={explanation}\n        keyVal={keyVal}\n        setKeyVal={setKeyVal}\n        test_text = {test_text }\n        setTestText={setTestText}\n        autoClusterLabel={autoClusterLabel}\n        setautoClusterLabel={setautoClusterLabel}\n        onautoClusterLabelchange = {getExplanationClusterLabel}\n      />\n    </div>\n  );\n};\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/LeftPanel.js",["167","168","169","170","171","172","173","174"],[],"import Container from \"react-bootstrap/Container\";\nimport Navbar from \"react-bootstrap/Navbar\";\nimport \"../App.css\";\nimport { useState, useEffect } from \"react\";\nimport Button from \"react-bootstrap/Button\";\nimport ToggleButton from 'react-bootstrap/ToggleButton'\nimport Menu from '@mui/material/Menu';\nimport MenuItem from '@mui/material/MenuItem';\nimport Form from \"react-bootstrap/Form\";\nimport axios from \"axios\";\nimport {\n  drawProjection,\n  clearSVG,\n  changeOpacity,\n  changeDotSize,\n  toggleDotDisplay,\n  autocheckPoints,\n} from \"../d3-rendering/projectionManipulationFunctions.js\";\nimport Tooltip from '@mui/material/Tooltip';\nimport Slider from \"@mui/material/Slider\";\nimport CircularProgress from \"@mui/material/CircularProgress\";\nimport { InfoTooltip } from \"./InfoTooltip.js\";\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faCheckSquare, faSquare } from \"@fortawesome/free-solid-svg-icons\";\nimport neurips from '../datasets/neurips.json';\n\n\nlibrary.add(faCheckSquare, faSquare);\n\nconst localDevURL = \"http://127.0.0.1:8000/\";\n\nconst LoadDataCircle = ({ loadingData }) => {\n  if (!loadingData) {\n    return <div></div>;\n  } else {\n    return <CircularProgress />;\n  }\n};\n\nconst Header = () => {\n  return (\n    <Navbar bg=\"dark\" variant=\"dark\">\n      <Container>\n        <Navbar.Brand href=\"#home\">Cluster Investigator</Navbar.Brand>\n      </Container>\n    </Navbar>\n  );\n};\n\nconst ReductionOptions = ({\n  reductionMethod,\n  perplexity,\n  perplexityChanger,\n}) => {\n  // Handle perplexity changes\n  const handlePerplexityChange = (event, newPerplexity) => {\n    if (newPerplexity !== perplexity) {\n      perplexityChanger(newPerplexity);\n    }\n  };\n\n  if (reductionMethod === \"TSNE\") {\n    return (\n      <div className=\"sliderBlock\">\n        <p>Perlexity</p>\n        <Slider\n          size=\"small\"\n          aria-label=\"perplexity\"\n          value={perplexity}\n          onChange={handlePerplexityChange}\n          min={0}\n          max={100}\n        />\n        <p className=\"paramValue\">{perplexity}</p>\n      </div>\n    );\n  } else if (reductionMethod === \"UMAP\") {\n    return <div></div>;\n  } else {\n    return <div></div>;\n  }\n};\n\n// Item in the category key\nconst KeyItem = ({ props }) => {\n  const [checked, setChecked] = useState(true);\n  const [checkedlabel, setCheckedLabel] = useState(props.label);\n\n  const handleClick = () => {\n    setChecked(!checked);\n    toggleDotDisplay(!checked, props.label);\n    autocheckPoints(props.label);\n  };\n\n  return (\n    <div className=\"key-item\" onClick={handleClick} spin>\n      {/* Custom checkbox */}\n      <FontAwesomeIcon\n        icon={checked ? \"check-square\" : \"square\"}\n        color={checked ? props.color : \"#FAFAFA\"}\n      />\n      <p>{props.label+\" : \"+props.keywords}</p>\n    </div>\n  );\n};\nwindow.onload = function(){\n  document.getElementById('toggleButton1').click();\n  //document.getElementById('toggleButton2').click();\n  document.getElementById('toggleButton3').click();\n\n\n}\n\n// Data upload + control panel\nexport const LeftPanel = ({ width, height }) => {\n  const [rawFile, setRawFile] = useState(); // File that hasn't been projected yet\n  const [plottedData, setPlottedData] = useState([]); // Holds data that's currently plotted\n  const [projectedFileData, setProjectedFileData] = useState([]); // Holds previously projected data that's being uploaded\n  const [opacity, setOpacity] = useState(50);\n  const [dotSize, setDotSize] = useState(2);\n  const [clusterThresholdDist, setclusterThresholdDist] = useState(1);\n  const [clusterMode, setClusterMode] = useState(false)\n  const [reductionMethod, setReductionMethod] = useState(\"none\");\n  const [perplexity, setPerplexity] = useState(50);\n  const [loadingData, setLoadingData] = useState(false);\n  const [csvOutput, setCsvOutput] = useState(\"\");\n  const [csvColumns, setCsvColumns] = useState([\n    <option key=\"select-a-column\" value=\"select-a-column\">\n      select a column to color dots by\n    </option>,\n  ]); //reset\n  const [colorMap, setColorMap] = useState({});\n  const [selectedCol, setSelectedCol] = useState(\"none\");\n\n\n  \n\n\n  function renderKey() {\n    if (colorMap.length > 0) {\n      return (\n        <>\n          <div className=\"title\">\n            <p>Cluster : Keywords</p>\n          </div>\n\n          {colorMap.map((info) => {\n\n            return (\n              <KeyItem\n                props={{\n                  label: info[0],\n                  color: info[1][0],\n                  keywords: info[1][1],\n                }}\n              />\n            );\n          })}\n        </>\n      );\n    }\n  }\n\n  // Help explanations\n  const uploadExplanation =\n    \"Upload a CSV with embeddings and metadata to project\";\n  const previousProjectionExplanation =\n    \"Here, you can upload JSON files saved using the 'bookmark projection' button below\";\n\n  // File reader\n  const fileReader = new FileReader();\n\n  // Set projected file on projected file upload\n  const handleProjectedFileChange = (e) => {\n    fileReader.onload = function (event) {\n      console.log(JSON.parse(event.target.result))\n      setProjectedFileData(JSON.parse(event.target.result));\n    };\n\n    fileReader.readAsText(e.target.files[0]);\n    \n  };\n\n  const [anchorEl, setAnchorEl] = useState(null);\n  const open = Boolean(anchorEl);\n  const handleClickMenu = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n  \n\n  const handleClose = (e,name) => {\n    setAnchorEl(null);\n    let loadedData = neurips\n\n      clearSVG();\n      setPlottedData(loadedData);\n      let newColorMap = drawProjection(width, height, loadedData);\n      setColorMap(Object.entries(newColorMap));\n      let req = {\n        data: JSON.stringify(loadedData),\n      };\n\n      axios //sending data to the backend\n        .post(localDevURL + \"quickload\", req)\n        .then((response) => {\n         console.log('Done')\n        })\n        .catch((error) => {\n          console.log(error);\n          setLoadingData(false);\n        });  \n    \n    \n\n    //fetch('neurips.json')\n    //.then((response) => response.json())\n    //.then((json) => console.log(json));\n  }\n\n  const toggleDiv = (e, id) => {\n    var x = document.getElementById(id);\n    if (x.style.display === \"none\") {\n      x.style.display = \"block\";\n    } else {\n      x.style.display = \"none\";\n    }\n  }\n\n\n  // For plotting previously projected data\n  const handleFilePlot = (e) => {\n    console.log(\"entering\")\n    // Clears svg and plots new data if there is new data\n    if (projectedFileData.length > 0) {\n      console.log(\"entering2\")\n\n      clearSVG();\n      setPlottedData(projectedFileData);\n      let newColorMap = drawProjection(width, height, projectedFileData);\n      setColorMap(Object.entries(newColorMap));\n      let req = {\n        data: JSON.stringify(projectedFileData),\n      };\n      console.log(projectedFileData)\n\n      axios //sending data to the backend\n        .post(localDevURL + \"quickload\", req)\n        .then((response) => {\n         console.log('Done')\n        })\n        .catch((error) => {\n          console.log(error);\n          setLoadingData(false);\n        });\n      setProjectedFileData([]);\n\n      \n    }\n  };\n\n  // Set raw file on raw file upload\n  const handleRawFileChange = (e) => {\n    setRawFile(e.target.files[0]);\n\n    // Uses first row from CSV to create dropdown of column names\n    let rows;\n    fileReader.onload = function (event) {\n      setCsvOutput(event.target.result);\n      console.log(event.target.result)\n\n\n      rows = event.target.result.split(\"\\n\");\n\n      let colNames = rows[0].split(\",\");\n\n      let colItems = [\n        <option key=\"select-a-column\" value=\"select-a-column\">\n          select a column to color dots by\n        </option>,\n        <option key=\"none\" value=\"none\">\n          none\n        </option>,\n      ];\n\n      for (let colName of colNames) {\n        colItems.push(\n          <option key={colName} value={colName}>\n            {colName}\n          </option>\n        );\n      }\n      setCsvColumns(colItems);\n      setSelectedCol(\"none\");\n    };\n\n    fileReader.readAsText(e.target.files[0]);\n  };\n\n  const handleColChange = (e) => {\n    setSelectedCol(e.target.value);\n  };\n\n  const handleReductionMethodChange = (e) => {\n    setReductionMethod(e.target.value);\n  };\n\n  //cost handleClusterThresholdChange\n\n  // Handle file projection\n  const handleFileProject = (e) => {\n    e.preventDefault();\n\n    // Submits post request if there is not a request already being processed\n    if (rawFile && !loadingData && reductionMethod !== \"none\") {\n      setLoadingData(true);\n\n      let req = {\n        data: csvOutput,\n        reductionMethod: reductionMethod,\n        selectedCol: selectedCol\n      };\n\n      // Constructing request based on reduction Method\n      if (reductionMethod === \"TSNE\") {\n        req.perplexity = perplexity;\n      }\n\n      axios //sending data to the backend\n        .post(localDevURL + \"upload-data\", req)\n        .then((response) => {\n         //console.log(\"SUCCESS\", response.data.data);\n          let dataToPlot = response.data.data;\n          clearSVG();\n          setPlottedData(dataToPlot);\n          let newColorMap = drawProjection(width, height, dataToPlot);\n          setColorMap(Object.entries(newColorMap));\n          setLoadingData(false);\n          //add something to send the cluster size to backend\n        })\n        .catch((error) => {\n          console.log(error);\n          setLoadingData(false);\n        });\n    } else if (!rawFile) {\n      alert(\"please upload a file\");\n    } else if (reductionMethod === \"none\") {\n      alert(\"please select a reduction method!\");\n      return;\n    }\n  };\n\n  // Handles save of currently projected data\n  const handleProjectionSave = (e) => {\n    const jsonString = `data:text/json;chatset=utf-8,${encodeURIComponent(\n      JSON.stringify(plottedData)\n    )}`;\n    // console.log(plottedData);\n    const link = document.createElement(\"a\");\n    link.href = jsonString;\n    link.download = \"data.json\";\n    link.click();\n  };\n\n  // SLIDERS\n\n  // Handle opacity changes\n  const handleOpacityChange = (event, newOpacity) => {\n    if (newOpacity !== opacity) {\n      setOpacity(newOpacity);\n    }\n  };\n\n  useEffect(() => {\n    //console.log(\"changing opacity\", opacity / 100);\n    changeOpacity(opacity / 100);\n  }, [opacity]);\n\n  // Handle dot size changes\n  const handleDotSizeChange = (event, newSize) => {\n    if (newSize !== dotSize) {\n      setDotSize(newSize);\n    }\n  };\n\n  useEffect(() => {\n   //console.log(\"changing dot size\", dotSize);\n    changeDotSize(dotSize);\n  }, [dotSize]);\n\n\n  // Handle cluster threshold distance changes\n  // const handleClusterThresholdDist = (event, newThreshold) => {\n    // if (newThreshold !== clusterThresholdDist) {\n    //   setclusterThresholdDist(newThreshold)\n    // }\n\n    \n  // }\n\n\n  const handleClusterThresholdDist = (event, newThreshold) => {\n    if (newThreshold !== clusterThresholdDist) {\n      setclusterThresholdDist(newThreshold)\n      //console.log(clusterThresholdDist)\n    }\n\n    // Submits post request if there is not a request already being processed\n    // if (clusterMode) {\n\n      let req = {\n        clusterThresholdDist: clusterThresholdDist\n      };\n\n      axios //sending data to the backend\n        .post(localDevURL + \"auto-cluster\", req)\n        .then((response) => {\n          //console.log(\"SUCCESS affected new cluster distance\");\n          let dataToPlot = response.data.data;\n          clearSVG();\n          setPlottedData(dataToPlot);\n          let newColorMap = drawProjection(width, height, dataToPlot);\n          setColorMap(Object.entries(newColorMap));\n          console.log(Object.entries(newColorMap));\n          setLoadingData(false);\n          //add something to send the cluster size to backend\n        })\n        .catch((error) => {\n          console.log(error);\n          setLoadingData(false);\n        });\n    // };\n    };\n\n  // useEffect(() => {\n  //   console.log(\"changing cluster threshold dist\", clusterThresholdDist);\n  //   let req = {\n  //     clusterThresholdDist: clusterThresholdDist\n  //   };\n\n\n  //   axios\n  //     .post(localDevURL + \"turn-on-cluster-mode\", req)\n  //     .then((response) => {\n  //       console.log(\"SUCCESS affected new cluster distance\");\n  //       let dataToPlot = response.data.data;\n  //       clearSVG();\n  //       setPlottedData(dataToPlot);\n  //       let newColorMap = drawProjection(width, height, dataToPlot);\n  //       setColorMap(Object.entries(newColorMap));\n  //     })\n  //     .catch((error) => {\n  //       console.log(error);\n  //     });\n  // }, [clusterThresholdDist])\n\n  // Draw graph ONCE when the component mounts\n  useEffect(() => {\n    console.log(\"running effect\");\n    axios\n      .get(localDevURL + \"get-default-data\")\n      .then((response) => {\n        let dataToPlot = response.data.data;\n        setPlottedData(dataToPlot);\n        let newColorMap = drawProjection(width, height, dataToPlot);\n        setColorMap(Object.entries(newColorMap));\n      })\n      .catch((error) => {\n        console.log(error);\n      });\n  }, [height, width]);\n\n  return (\n    \n    <div className=\"left panel\">\n    <h2>Cluster Explainer</h2>\n\n      <Tooltip title={uploadExplanation} arrow>\n        <Button  id=\"toggleButton1\" class=\"btn btn-secondary btn-xs\" onClick={(e) => { toggleDiv(e, \"upload-div\");}}>UPLOAD DATA</Button>\n        </Tooltip>\n      <div id =\"upload-div\">\n        {/* File selection */}\n        <Form.Group controlId=\"formFile\" className=\"mb-3\">\n              <Form.Control\n                className=\"form-control input-sm\"\n                size=\"sm\"\n                type=\"file\"\n                accept=\".csv\"\n                onChange={handleRawFileChange}\n              />\n              <Form.Select\n                className=\"form-select input-sm\"\n                size=\"sm\"\n                aria-label=\"column-selection\"\n                onChange={handleColChange}\n              >\n                {csvColumns}\n              </Form.Select>\n              <Form.Select\n                className=\"form-select input-sm\"\n                size=\"sm\"\n                aria-label=\"column-selection\"\n                onChange={handleReductionMethodChange}\n              >\n                <option key=\"none\" value=\"none\">\n                  select a reduction method\n                </option>\n                <option key=\"TSNE\" value=\"TSNE\">\n                  T-SNE\n                </option>\n                <option key=\"UMAP\" value=\"UMAP\">\n                  UMAP\n                </option>\n              </Form.Select>\n        </Form.Group>\n\n        {/* TODO: add column selector*/}\n        {/* Dimensionality reduction method selection */}\n        <ReductionOptions\n          reductionMethod={reductionMethod}\n          perplexity={perplexity}\n          perplexityChanger={setPerplexity}\n            />\n        <div className=\"submitButton\">\n              <Button\n                size=\"sm\"\n                id=\"dataUploadButton\"\n                variant=\"secondary\"\n                onClick={(e) => {\n                  handleFileProject(e);\n                }}\n              >\n                Project\n              </Button>\n              <LoadDataCircle loadingData={loadingData} />\n        </div>\n        {/* Use previously cached projection */}\n\n        <Form.Group controlId=\"previousProjectionFile\" className=\"mb-3\">\n        <Form.Control\n          className=\"form-control input-sm\"\n          size=\"sm\"\n          type=\"file\"\n          accept=\".json\"\n          onChange={handleProjectedFileChange}\n        />\n      </Form.Group>\n      <div className=\"button-box\">\n        <Button\n          size=\"sm\"\n          id=\"cachedDataButton\"\n          variant=\"secondary\"\n          onClick={(e) => {\n            handleFilePlot(e);\n          }}\n        >\n          Load\n        </Button>\n        <Button\n          size=\"sm\"\n          id=\"bookmarkButton\"\n          variant=\"outline-secondary\"\n          onClick={(e) => {\n            handleProjectionSave(e);\n          }}\n        >\n          Download Projection\n        </Button>\n        </div>\n      </div>\n      \n\n      <Button\n        id=\"demo-positioned-button\"\n        class=\"btn btn-secondary btn-xs\"\n        aria-controls={open ? 'demo-positioned-menu' : undefined}\n        aria-haspopup=\"true\"\n        aria-expanded={open ? 'true' : undefined}\n        onClick={handleClickMenu}\n      >\n        Quick Load\n      </Button>\n      <Menu\n        id=\"demo-positioned-menu\"\n        aria-labelledby=\"demo-positioned-button\"\n        anchorEl={anchorEl}\n        open={open}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: 'top',\n          horizontal: 'left',\n        }}\n        transformOrigin={{\n          vertical: 'top',\n          horizontal: 'left',\n        }}\n      >\n        <MenuItem onClick={(e) => { handleClose(e, \"neurips\");}}>NeurIPS 2022</MenuItem>\n        <MenuItem onClick={(e) => { handleClose(e, \"rlhf\");}}>RLHF Dataset</MenuItem>\n        <MenuItem onClick={(e) => { handleClose(e, \"vispapers\");}}>Vis Paper Abstracts</MenuItem>\n      </Menu>\n\n      <Button  id=\"toggleButton3\" class=\"btn btn-secondary btn-xs display-btn\" onClick={(e) => { toggleDiv(e, \"displaysettings-div\");}}>DISPLAY SETTINGS</Button>\n      <div id =\"displaysettings-div\">\n      <div className=\"sliderBlock\">\n        <p>Opacity</p>\n        <Slider\n          size=\"small\"\n          aria-label=\"opacity\"\n          value={opacity}\n          onChange={handleOpacityChange}\n          step={10}\n          marks\n          min={0}\n          max={100}\n        />\n        <p className=\"paramValue\">{opacity}</p>\n      </div>\n      <div className=\"sliderBlock\">\n        <p className=\"sliderLabel\">Dot Size</p>\n        <Slider\n          size=\"small\"\n          aria-label=\"dot-size\"\n          value={dotSize}\n          onChange={handleDotSizeChange}\n          step={0.5}\n          marks\n          min={0}\n          max={5}\n        />\n        <p className=\"paramValue\">{dotSize}</p>\n      </div>\n      </div>\n      <div>\n      <h3>AutoCluster</h3>\n      </div>\n      <div className=\"sliderBlock\">\n      <p>Few</p><Slider\n            aria-label=\"AutoCluster Number\"\n            valueLabelDisplay=\"auto\"\n            value={clusterThresholdDist}\n            onChange={handleClusterThresholdDist}\n            step={1}\n            marks\n            min={1}\n            max={50}\n          /><p>  Many</p>\n      </div>\n      {/* <div className=\"submitButton\">\n        <Button\n          size=\"sm\"\n          id=\"changeClusterMode\"\n          variant=\"secondary\"\n          onClick={setClusterMode(!clusterMode)}\n        >\n          project\n        </Button>\n      </div> */}\n      {renderKey()}\n\n      \n\n      </div>\n  );\n};\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/RightPanel.js",["175","176","177"],[],"import \"../App.css\";\nimport { useState, useEffect } from \"react\";\nimport Table from \"react-bootstrap/Table\";\nimport Form from \"react-bootstrap/Form\";\nimport Button from \"react-bootstrap/Button\";\nimport styled, { keyframes } from \"styled-components\";\nimport Slider from \"@mui/material/Slider\";\nimport axios from \"axios\";\n\n\n\n\nimport {\n  highlightLabel,\n  getCentroid,\n  findMatchingPoints,\n  clearSelectedMatchingPoints,\n  reset,\n  drawTestProjection,\n} from \"../d3-rendering/projectionManipulationFunctions.js\";\nimport { InfoTooltip } from \"./InfoTooltip.js\";\nimport { text } from \"d3\";\n\n\nconst localDevURL = \"http://127.0.0.1:8000/\";\n\nconst DEFAULT_PROMPT =\n  \"What is the common theme between the selected sentences?\";\n\n// Loading animation\nconst breatheAnimation = keyframes`\n 0% { opacity: 0.6; }\n 50% { opacity: 1; }\n 100% { opacity: 0.6; }`;\n\nconst PlaceholderImage = styled.img`\n  animation-name: ${breatheAnimation};\n  animation-duration: 1.5s;\n  animation-iteration-count: infinite;\n`;\n\nconst LabelSearch = () => {\n  const [substring, setSubstring] = useState(\"\");\n\n  const handleSubstringChange = (e) => {\n    setSubstring(e.target.value);\n  };\n\n  const enterSubmit = (e) => {\n    if (e.key === \"Enter\") {\n      handleSubmit();\n    }\n  };\n\n  const handleSubmit = () => {\n    clearSelectedMatchingPoints();\n    reset();\n    findMatchingPoints(substring);\n  };\n\n  const handleReset = () => {\n    clearSelectedMatchingPoints();\n    reset();\n  };\n\n  return (\n    <>\n      <Form.Group className=\"mb-3\" controlId=\"findSubstring\">\n          \n        <div className=\"button-box\">\n          <Form.Control\n            type=\"substring\"\n            size=\"sm\"\n            placeholder=\"Enter Keywords\"\n            onChange={handleSubstringChange}\n            onKeyPress={enterSubmit}\n          />\n          <Button\n            size=\"sm\"\n            variant=\"secondary\"\n            type=\"submit\"\n            onClick={handleSubmit}\n          >\n            Search\n          </Button>\n          <Button\n            size=\"sm\"\n            variant=\"outline-secondary\"\n            className=\"resetButton\"\n            onClick={handleReset}\n          >\n            reset\n          </Button>\n        </div>\n      </Form.Group>\n    </>\n  );\n};\n\n// Analysis panel for displaying info\nexport const RightPanel = ({\n  selectedPoints,\n  pathPoints,\n  topWords,\n  wordsLoading,\n  prompt,\n  setPrompt,\n  explanation,\n  keyVal,\n  setKeyVal,\n  test_text,\n  setTestText,\n  autoClusterLabel,\n  setautoClusterLabel,\n  onautoClusterLabelchange \n}) => {\n  const [selectedItems, setSelectedItems] = useState([]);\n  const [promptValue, setPromptValue] = useState(prompt);\n  const associatedWordsExplanation =\n    \"We run a linear classifier on points in the circled area versus points not in the circled area. We return the top 30 words that are positively and negatively associated with being in the circled area\";\n\n  // Generates table items if there are selected points\n  useEffect(() => {\n    if (selectedPoints.length > 0) {\n      let labelDict = {};\n\n      // Calculates centroid of lassoed area\n      console.log(pathPoints,selectedPoints)\n\n      let centroid = {x:0, y:0}\n\n      if (pathPoints.length != 0) {\n        let centroid = getCentroid(pathPoints);\n\n      }\n\n      for (let point of selectedPoints) {\n        // Creates ids for a table item, if there are multiple of the same label, this allows you to map from the table item to the labels\n        if (point.label in labelDict) {\n          labelDict[point.label].id =\n            labelDict[point.label].id + \" \" + point.id;\n        } else {\n          labelDict[point.label] = { id: point.id };\n        }\n\n        // Calculates distance from the centroid of the lassoed area to the point\n        labelDict[point.label].distFromCentroid = Math.sqrt(\n          (point.cx - centroid.x) ** 2 + (point.cy - centroid.y) ** 2\n        );\n      }\n\n      // Sorts labels by distance from the centroid\n      let labelsArray = Object.entries(labelDict);\n      labelsArray.sort(function (a, b) {\n        return a[1].distFromCentroid - b[1].distFromCentroid;\n      });\n\n      let newSelectedItems = [];\n      for (let [label, countInfo] of labelsArray) {\n        // Highlights top words in the label if topwords is populated\n        if (topWords.positiveWord !== null) {\n          let splitLabel = label.split(\" \");\n          for (let i = splitLabel.length - 1; i > -1; i--) {\n            let lowercaseCopy = splitLabel[i]\n              .toLowerCase()\n              .replace(/[.,/#!$?%^&*;:\"{}=\\-_`~()]/g, \"\");\n\n            switch (lowercaseCopy) {\n              case topWords.positiveWords[0]:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"positive-mark-1\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              case topWords.positiveWords[1]:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"positive-mark-2\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              case topWords.positiveWords[2]:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"positive-mark-3\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              case topWords.negativeWord:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"negative-mark\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              default:\n                break;\n            }\n\n            // Adds space\n            if (i === splitLabel.length - 1) {\n              continue;\n            } else {\n              splitLabel.splice(i + 1, 0, \" \");\n            }\n          }\n          label = splitLabel;\n          // console.log(\"newLabel\", lab el);\n        }\n        newSelectedItems.push(\n          <tr key={countInfo.id} onClick={(e) => highlightLabel(e)}>\n            <td>{newSelectedItems.length + 1}</td>\n            <td id={countInfo.id} className=\"label\">\n              {label}\n            </td>\n          </tr>\n        );\n      }\n\n      setSelectedItems(newSelectedItems);\n    } // Update selected items if selection is cleared\n    else if (selectedPoints.length === 0 && selectedItems.length > 0) {\n      setSelectedItems([]);\n    }\n  }, [selectedPoints, topWords, pathPoints, selectedItems.length]);\n\n  const handleNewPrompt = (e) => {\n    if (promptValue !== \"\") {\n      setPrompt(promptValue);\n    }\n\n    console.log(promptValue);\n\n    document.querySelector(\"#promptTextArea\").value = \"\";\n  };\n\n  const handleChangePrompt = (e) => {\n    setPromptValue(e.target.value);\n  };\n\n  \n\n  const handleChangeText = (e) => {\n    setTestText(e.target.value)\n};\n\nconst handleTextClick = (e) => {\n  axios\n    .post(localDevURL + \"test-projection\", {\n      text: test_text,\n    })\n    .then((response) => {\n      drawTestProjection(response.data.data)\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n};\n\n  \n\n  const handleChangeKey = (e) => {\n    console.log(\"setting key value:\", e.target.value);\n    setKeyVal(e.target.value);\n  };\n\n  const handleChangeautoClusterLabel = (e) => {\n    console.log(\"setting clusterlabel value:\", e.target.value);\n    setautoClusterLabel(e.target.value);\n    onautoClusterLabelchange()\n  };\n  \n  const handleReset = () => {\n    setPrompt(DEFAULT_PROMPT);\n    document.querySelector(\"#promptTextArea\").value = \"\";\n  };\n\n\n  return (\n    <div className=\"right panel\">\n      <LabelSearch />\n      <hr />\n      <div id=\"auto-explanation\">\n        <p className=\"title\">AutoCluster Explanation</p>\n        <div className=\"autoExplanationslider\">\n          <Slider\n            aria-label=\"AutoCluster Label\"\n            value={autoClusterLabel}\n            valueLabelDisplay=\"auto\"\n            onChange={handleChangeautoClusterLabel}\n            step={1}\n            marks\n            min={1}\n            max={30}\n          />\n      </div></div>\n      <hr />\n      <div id=\"new-text\">\n      <p className=\"title\">Explanation by Example</p>\n\n      <Form.Control\n            className=\"form-control\"\n            id=\"TestProjectionArea\"\n            size=\"sm\"\n            as=\"textarea\"\n            placeholder={\"Enter Text Here to creat new projection point\"}\n            onChange={handleChangeText}\n          ></Form.Control>\n      <Button\n            size=\"sm\"\n            variant=\"secondary\"\n            type=\"submit\"\n            onClick={handleTextClick}>\n            Show\n          </Button>\n          </div>\n          <hr />\n\n      <div className=\"title\">\n        <p>Explanation as keywords</p>\n        <InfoTooltip text={associatedWordsExplanation} />\n      </div>\n      <div id=\"cloud-div\">\n        <div id=\"positive-cloud-div\">\n          {wordsLoading ? (\n            <PlaceholderImage\n              src=\"https://storage.googleapis.com/htw-website-uploads/Grey-placeholder-image2.jpg\"\n              className=\"placeholder-image\"\n              id=\"pos-placeholder\"\n            />\n          ) : null}\n        </div>\n      </div>\n      <hr />\n\n      <div id=\"natural-language-explanation\">\n        <p className=\"title\">Explanation by Interaction</p>\n        <Form.Group>\n          <Form.Control\n            className=\"form-control\"\n            size=\"sm\"\n            placeholder={keyVal === \"\" ? \"OpenAI Key\" : keyVal}\n            onChange={handleChangeKey}\n          ></Form.Control>\n          <Form.Control\n            className=\"form-control\"\n            id=\"promptTextArea\"\n            size=\"sm\"\n            as=\"textarea\"\n            rows={3}\n            placeholder={\"current prompt: \" + prompt}\n            onChange={handleChangePrompt}\n          ></Form.Control>\n          <div className=\"button-box\">\n            <Button\n              size=\"sm\"\n              variant=\"secondary\"\n              type=\"submit\"\n              onClick={handleNewPrompt}\n            >\n              Set Prompt\n            </Button>\n            <Button\n              size=\"sm\"\n              variant=\"outline-secondary\"\n              className=\"resetButton\"\n              onClick={handleReset}\n            >\n              Reset\n            </Button>\n          </div>\n        </Form.Group>\n        <Form.Control\n            className=\"form-control\"\n            id=\"explanation\"\n            size=\"sm\"\n            as=\"textarea\"\n            rows={3}\n            placeholder={explanation}\n            //onChange={handleChangePrompt}\n          ></Form.Control>\n      </div>\n      <hr />\n\n      <div id=\"unique-items-div\">\n        <p className=\"title\">\n          {selectedItems.length > 0\n            ? selectedItems.length + \" total unique\"\n            : 0}{\" \"}\n          items\n        </p>\n      </div>\n      <div className=\"tableDiv\">\n        <Table bordered>\n          <thead>\n            <tr>\n              <th>#</th>\n              <th>Item</th>\n            </tr>\n          </thead>\n          <tbody>{selectedItems}</tbody>\n        </Table>\n      </div>\n      <div className=\"footerSpacing\"></div>\n    </div>\n  );\n};\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/components/InfoTooltip.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/d3-rendering/cloudFunctions.js",["178"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Cluster-Research-new/frontend/src/d3-rendering/projectionManipulationFunctions.js",["179"],[],"import * as d3 from \"d3\";\n\n// Storing state location data for quicker access\n/*\n  Schema:\n  database = {\n    id: {\n      cx: float\n      cy: float\n      label: string\n      originalColor: color\n    }\n  }\n  */\n\n// Global variables\nlet database = {}; // Database of projected points\nlet colorMap = {}; // Map of label --> color\nlet globalOpacity = 0.5; // Default opacity\nlet globalDotSize = 2; // Default dot size\n\n// Clears SVG in the center panel when new data is uploaded\nfunction clearSVG() {\n  var svg = d3.select(\"#containerSVG\");\n  svg.selectAll(\"circle\").remove(); // Removes plotted points\n  svg.selectAll(\"#lasso\").attr(\"d\", \"\"); // Resets lasso\n}\n\n// Function to draw projection, called once at render time and when new data is uploaded\n/*\n  Schema:\n  width = float\n  height = float\n  uploadedData = [x, y, label, color(if color column selected)]\n*/\nfunction drawProjection(width, height, uploadedData) {\n  let data = JSON.parse(JSON.stringify(uploadedData));\n  // Location var\n  const MARGIN = { top: 20, right: 0, bottom: 50, left: 85 },\n    SVG_X = width,\n    SVG_Y = height,\n    PLOT_X = SVG_X - MARGIN.right - MARGIN.left,\n    PLOT_Y = SVG_Y - MARGIN.top - MARGIN.bottom;\n\n  let x = d3.scaleLinear().range([MARGIN.left, PLOT_X]),\n    y = d3.scaleLinear().range([PLOT_Y, MARGIN.top]);\n\n\n    \n  // SVG\n  var svg = d3.select(\"#containerSVG\")//.call(d3.zoom().on(\"zoom\", function handleZoom(event) { svg.attr(\"transform\",event.transform) }));\n  //d3.select(\"#containerSVG\").on('mousedown.zoom',null);\n  // Re-setting database and colorMap and using uploaded data to draw when data has been loaded\n  database = {};\n  colorMap = {};\n\n  if (data[0].length === 5) {\n    makeColorMap(data);\n  }\n\n  var d_extent_x = d3.extent(data, (d) => +d[0]),\n    d_extent_y = d3.extent(data, (d) => +d[1]);\n\n  // Draw axes\n  x.domain(d_extent_x);\n  y.domain(d_extent_y);\n\n  // Generate IDs for points\n  for (let row of data) {\n    row.push(makeid(10));\n  }\n\n  // Draw circles\n  svg\n    .append(\"g\")\n    .selectAll(\"circle\")\n    .data(data)\n    .enter()\n    .append(\"circle\")\n    .attr(\"r\", globalDotSize)\n    .attr(\"opacity\", globalOpacity)\n    .attr(\"id\", (d) => {\n      let id = d[d.length - 1];\n      database[id] = { label: d[2], keyword:d[4]};\n      return id;\n    })\n    .attr(\"cx\", (d) => {\n      let centerX = x(+d[0]);\n      database[d[d.length - 1]].cx = centerX;\n      return centerX;\n    })\n    .attr(\"cy\", (d) => {\n      let centerY = y(+d[1]);\n      database[d[d.length - 1]].cy = centerY;\n      return centerY;\n    })\n    .attr(\"fill\", (d) => {\n      if (d.length === 6) {\n        return assignColor(d[3], d[5]);\n      } else {\n        database[d[d.length - 1]].originalColor = \"black\";\n        return \"black\";\n      }\n    })\n    .attr(\"class\", \"non-brushed\");\n  colorMap.x = x\n  colorMap.y = y\n  console.log(colorMap,x,y)\n  svg.append(\"g\");\n  return colorMap;\n}\n\nfunction drawTestProjection(data) {\n\n  var svg2 = d3.select(\"#containerSVG\")\n  var x = colorMap.x \n  var y = colorMap.y\n  console.log(x,y)\n  let id = \"test_text\";\n  // Draw circles\n  svg2\n    .append(\"g\")\n    .selectAll(\"circle\")\n    .data(data)\n    .enter()\n    .append(\"circle\")\n    .attr(\"r\", 0)\n    .attr(\"opacity\", 1)\n    .attr(\"id\", (d) => {\n      \n      database[id] = { label: d[2], keyword:d[4]};\n      return id;\n    })\n    .attr(\"cx\", (d) => {\n      let centerX = x(+d[0]);\n      database[id].cx = centerX;\n      return centerX;\n    })\n    .attr(\"cy\", (d) => {\n      let centerY = y(+d[1]);\n      database[id].cy = centerY;\n      return centerY;\n    })\n    .attr(\"fill\", 'green')\n    .transition().duration(200).attr(\"r\", 10)\n\n}\n\nfunction makeColorMap(data) {\n  let uniqueCategories = new Set();\n  let uniqueKeywords = new Set();\n\n  for (let item of data) {\n    \n    if (uniqueCategories.has(item[3])) {\n      continue;\n    } else {\n      uniqueCategories.add(item[3]);\n      uniqueKeywords.add(item[4]);\n    }\n  }\n  \n\n\n  let categoriesArray = Array.from(uniqueCategories);\n  let keywordsArray = Array.from(uniqueKeywords);\n  console.log(categoriesArray ,keywordsArray)\n  for (let i = 0; i < categoriesArray.length; i++) {\n    colorMap[categoriesArray[i]] = [COLORS[i % 11], keywordsArray[i]]  ;\n  }\n  \n}\n\nconst COLORS = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000'\n];\n\nfunction assignColor(category, id) {\n  database[id].category = category;\n  database[id].originalColor = colorMap[category][0];\n  return colorMap[category][0];\n}\n\n// Displays dots based on if the checkbox corresponding to their color is checked\nfunction toggleDotDisplay(checked, label) {\n  d3.selectAll(\"circle\")\n    .filter(function () {\n      if (database[d3.select(this).attr(\"id\")]) {\n        return database[d3.select(this).attr(\"id\")].category === +label;\n      } else {\n        return false;\n      }\n    }).transition().duration(200)\n    .attr(\"visibility\", function () {\n      if (checked) {\n        return \"visible\";\n      } else {\n        return \"hidden\";\n      }\n    })\n    .attr(\"opacity\", function () {\n      if (checked) {\n        return \"1\";\n      } else {\n        return \"0\";\n      }\n    });\n}\n\n// Check if points are within path on mouseup\nfunction checkPoints() {\n  var path = document.getElementById(\"lasso\");\n  let svg = document.getElementsByTagName(\"svg\")[0];\n  let brushedPoints = [];\n  let categorizedPoints = [];\n  let selectedLabels = [];\n  // d3.polygonContains(lassoPolygon, [x, y]);\n  for (let [id, idInfo] of Object.entries(database)) {\n    // Ignores point if it's not currently displayed\n    if (d3.select(\"#\" + id).attr(\"visibility\") === \"hidden\") {\n      continue;\n    }\n    const point = svg.createSVGPoint();\n\n    point.x = idInfo.cx;\n    point.y = idInfo.cy;\n    // Check if point is in path\n    if (path.isPointInFill(point)) {\n      idInfo.id = id;\n      brushedPoints.push(idInfo);\n      categorizedPoints.push([idInfo.label, 1]);\n      selectedLabels.push(idInfo.label);\n      // Change class and recolor points accordingly\n      let selector = \"#\" + id;\n      d3.selectAll(selector)\n        .attr(\"class\", function () {\n          const CURRENT_CLASS = d3.select(this).attr(\"class\");\n          if (CURRENT_CLASS.includes(\"brushed\")) {\n            return CURRENT_CLASS;\n          } else {\n            return \"brushed\";\n          }\n        })\n        .attr(\"fill\", (d, i, elements) => {\n          let color = database[id].originalColor;\n          if (d3.select(elements[i]).attr(\"class\").includes(\"brushed\")) {\n            if (Object.entries(colorMap).length > 0) {\n              color = \"black\"; \n              //color = \"red\"\n            } else {\n              color = \"orange\";\n            }\n          }\n\n          return color;\n        });\n    } else categorizedPoints.push([idInfo.label, 0]);\n  }\n\n  return {\n    brushedPoints: brushedPoints,\n    categorizedPoints: categorizedPoints,\n    selectedLabels: selectedLabels,\n  };\n}\n\nfunction autocheckPoints(label) {\n  console.log(\"in auto checkpoints\")\n  let brushedPoints = [];\n  let categorizedPoints = [];\n  let selectedLabels = [];\n  // d3.polygonContains(lassoPolygon, [x, y]);\n\n  for (let [id, idInfo] of Object.entries(database)) {\n    // Ignores point if it's not currently displayed\n    let selector = \"#\" + id;\n    if (database[id].category === +label) {\n      idInfo.id = id;\n      brushedPoints.push(idInfo);\n      categorizedPoints.push([idInfo.label, 1]);\n      selectedLabels.push(idInfo.label);\n\n      \n      d3.selectAll(selector).transition().duration(200)\n          .attr('r', 3*globalDotSize).attr(\"opacity\", 1)\n      \n    } else {categorizedPoints.push([idInfo.label, 0]);\n      d3.selectAll(selector).transition().duration(200)\n      .attr('r', globalDotSize).attr(\"opacity\", globalOpacity)}\n  }\n\n  return {\n    brushedPoints: brushedPoints,\n    categorizedPoints: categorizedPoints,\n    selectedLabels: selectedLabels,\n  };\n}\n// Reset projection to original state\nfunction reset() {\n  // Remove word clouds\n  d3.select(\"#positive-cloud\").remove();\n  d3.select(\"#negative-cloud\").remove();\n\n  // Re-color points\n  d3.selectAll(\"circle\")\n    .filter(function () {\n      if (d3.select(this).attr(\"class\").includes(\"matches-substring\")) {\n        return false;\n      } else {\n        return true;\n      }\n    })\n    .attr(\"class\", \"prev-brushed\").transition().duration(200)\n    //.attr(\"fill\", function () {\n    //  let color =\n    //    database[d3.select(this).attr(\"id\")] === undefined\n    //      ? \"black\"\n    //      : database[d3.select(this).attr(\"id\")].originalColor;\n    //  return color;\n    //})\n    .attr(\"r\", globalDotSize)\n    .attr(\"opacity\", globalOpacity);\n\n  // Remove point label\n  d3.selectAll(\".pointLabel\").transition().duration(200).remove();\n\n  // Reset lasso\n  d3.selectAll(\"#lasso\").transition().duration(200).attr(\"d\", \"\");\n}\n\n// Make random id strings\nfunction makeid(length) {\n  var result = \"\";\n  var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nfunction changeOpacity(opacity) {\n  d3.selectAll(\"circle\").attr(\"opacity\", opacity);\n  globalOpacity = opacity;\n}\nfunction changeDotSize(dotSize) {\n  d3.selectAll(\"circle\").attr(\"r\", dotSize);\n  globalDotSize = dotSize;\n}\n\nfunction highlightLabel(event) {\n  // Reset previously highlighted labels\n  d3.selectAll(\".brushed\").transition().duration(200)\n    .attr(\"fill\", \"orange\")\n    .attr(\"opacity\", globalOpacity)\n    .attr(\"class\", \"brushed\")\n    .attr(\"r\", globalDotSize);\n  let ids = event.target.id.split(\" \");\n\n  // Highlight labels corresponding to ids\n  for (let id of ids) {\n    d3.select(\"#\" + id).transition().duration(200)\n      .attr(\"fill\", \"green\")\n      .attr(\"class\", \"brushed selected\")\n      .attr(\"opacity\", globalOpacity + 0.5)\n      .attr(\"r\", globalDotSize + 4);\n  }\n}\n\n// Draws tool tip for specific point on hover\nfunction drawToolTip(id, width) {\n  let pointInfo = database[id];\n  let svg = d3.select(\"#containerSVG\");\n  let toolTipWidth = 340;\n  let rectPadding = 1;\n  let hasCategory = database[id].originalColor !== \"black\" ? true : false;\n\n  // If dot is on right side of screen, flip tooltip\n  let leftflip = false;\n  if (pointInfo.cx > width / 2) {\n    leftflip = true;\n  }\n\n  // If dot is too high up, flip tooltip\n  let bottomflip = false;\n\n  // Draw tooltip of label text with rectangular border\n  // g element to hold the rect and text\n  var pointLabelContainer = svg\n    .append(\"g\")\n    .attr(\"transform\", \"translate(\" + pointInfo.cx + \",\" + pointInfo.cy + \")\")\n    .attr(\"class\", \"pointLabel\")\n    .attr(\"id\", id + \"label\");\n\n  // Text\n  let toytext = pointLabelContainer\n    .append(\"text\")\n    .text(\"item: \" + pointInfo.label)\n    .attr(\"x\", () => {\n      if (!leftflip) {\n        return rectPadding + \"em\";\n      } else {\n        return -toolTipWidth;\n      }\n    })\n    .attr(\"y\", -60 + rectPadding + 12)\n    .attr(\"id\", \"toyText\");\n\n  let lines = wrap(toytext, toolTipWidth - 2 * rectPadding);\n\n  d3.select(\"#toyText\").remove();\n\n  // Rect\n  let toolTipHeight = 1.1 * (lines + 1) + 1;\n\n  // Flips tooltip if it's too close to the top\n  if (pointInfo.cy < 100) {\n    bottomflip = true;\n  }\n\n  if (hasCategory) {\n    toolTipHeight = 1.1 * (lines + 4) + 1;\n  }\n\n  pointLabelContainer\n    .append(\"rect\")\n    .attr(\"x\", () => {\n      if (!leftflip) {\n        return 10;\n      } else {\n        return -(toolTipWidth + 10);\n      }\n    })\n    .attr(\"y\", () => {\n      if (!bottomflip) {\n        return -3 + \"em\";\n      } else {\n        return 0;\n      }\n    })\n    .attr(\"width\", toolTipWidth)\n    .attr(\"height\", toolTipHeight + \"em\")\n    .attr(\"fill\", \"white\")\n    .attr(\"stroke\", \"black\")\n    .attr(\"stroke-width\", \"1px\")\n    .style(\"z-index\", \"1\");\n\n  // Change fill/size of the corresponding point\n  d3.select(\"#\" + id)\n    .attr(\"fill\", \"green\")\n    .attr(\"opacity\", globalOpacity + 0.5)\n    .attr(\"r\", globalDotSize + 2);\n\n  pointLabelContainer\n    .append(\"text\")\n    .text(\"item: \" + pointInfo.label)\n    .attr(\"x\", () => {\n      if (!leftflip) {\n        return rectPadding + \"em\";\n      } else {\n        return -toolTipWidth;\n      }\n    })\n    .attr(\"y\", () => {\n      if (!bottomflip) {\n        return -3 + rectPadding + 0.3 + \"em\";\n      } else {\n        return rectPadding + 0.3 + \"em\";\n      }\n    })\n    .style(\"z-index\", \"10\")\n    .attr(\"font-family\", \"Arial\")\n    .attr(\"fill\", \"black\")\n    .attr(\"stroke-width\", \"1px\")\n    .style(\"z-index\", \"10\")\n    .attr(\"vector-effect\", \"non-scaling-stroke\")\n    .call(wrap, toolTipWidth - 2 * 10);\n\n  // Add category information if has category\n  if (hasCategory) {\n    pointLabelContainer\n      .append(\"text\")\n      .text(\"category: \" + pointInfo.category)\n      .attr(\"x\", () => {\n        if (!leftflip) {\n          return rectPadding + \"em\";\n        } else {\n          return -toolTipWidth;\n        }\n      })\n      .attr(\"y\", () => {\n        if (!bottomflip) {\n          return -3 + toolTipHeight - 1.1 + \"em\";\n        } else {\n          return toolTipHeight - 1.1 + \"em\";\n        }\n      })\n      .style(\"z-index\", \"10\")\n      .attr(\"font-family\", \"Arial\")\n      .attr(\"fill\", \"black\")\n      .attr(\"stroke-width\", \"1px\")\n      .style(\"z-index\", \"10\")\n      .attr(\"vector-effect\", \"non-scaling-stroke\");\n  }\n}\n\n// Function for wrapping svg text elements\nfunction wrap(text, width) {\n  let lines = 0;\n  text.each(function () {\n    var text = d3.select(this),\n      words = text.text().split(/\\s+/).reverse(),\n      word,\n      line = [],\n      lineNumber = 0,\n      lineHeight = 1.1, // ems\n      x = text.attr(\"x\"),\n      y = text.attr(\"y\"),\n      dy = 0, //parseFloat(text.attr(\"dy\")),\n      tspan = text\n        .text(null)\n        .append(\"tspan\")\n        .attr(\"x\", x)\n        .attr(\"y\", y)\n        .attr(\"dy\", dy + \"em\");\n    while ((word = words.pop())) {\n      line.push(word);\n      tspan.text(line.join(\" \"));\n      if (tspan.node().getComputedTextLength() > width) {\n        line.pop();\n        tspan.text(line.join(\" \"));\n        line = [word];\n        tspan = text\n          .append(\"tspan\")\n          .attr(\"x\", x)\n          .attr(\"y\", y)\n          .attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\")\n          .text(word);\n      }\n    }\n    lines = lineNumber;\n  });\n\n  return lines;\n}\n\n// Uses the ID of a point to remove the corresponding tooltip on mouseOut\nfunction eraseToolTip(id) {\n  const POINT_CLASS_NAME = d3.select(\"#\" + id).attr(\"class\");\n\n  // Remove the tooltip\n  d3.select(\"#\" + id + \"label\").remove();\n\n  // Reset points to appropriate fill, opacity, and radius based on state\n  d3.select(\"#\" + id)\n    .attr(\"fill\", () => {\n      switch (POINT_CLASS_NAME) {\n        case \"brushed\":\n          return \"orange\";\n        case \"brushed selected\":\n          return \"green\";\n        case \"matches-substring brushed\":\n          return \"orange\";\n        default:\n          return database[id].originalColor; //////////******fix if the state is that it is currently selected, then stay black */\n          // return \"red\"\n      }\n    })\n    .attr(\"opacity\", () => {\n      switch (POINT_CLASS_NAME) {\n        case \"brushed\":\n          return globalOpacity;\n        case \"brushed selected\":\n          return globalOpacity + 0.5;\n        default:\n          return globalOpacity;\n      }\n    })\n    .attr(\"r\", () => {\n      switch (POINT_CLASS_NAME) {\n        case \"brushed\":\n          return globalDotSize;\n        case \"brushed selected\":\n          return globalDotSize + 2;\n        default:\n          return globalDotSize;\n      }\n    });\n}\n\n// Gets centroid of set of points\nfunction getCentroid(points) {\n  var first = points[0],\n    last = points[points.length - 1];\n  if (first.x !== last.x || first.y !== last.y) points.push(first);\n  var twicearea = 0,\n    x = 0,\n    y = 0,\n    nPoints = points.length,\n    p1,\n    p2,\n    f;\n  for (var i = 0, j = nPoints - 1; i < nPoints; j = i++) {\n    p1 = points[i];\n    p2 = points[j];\n    f = p1.x * p2.y - p2.x * p1.y;\n    twicearea += f;\n    x += (p1.x + p2.x) * f;\n    y += (p1.y + p2.y) * f;\n  }\n  f = twicearea * 3;\n  return { x: x / f, y: y / f };\n}\n\nfunction findMatchingPoints(substring) {\n  substring = substring.toLowerCase();\n  // Changes opacity of dots to look like something's loading\n  // d3.selectAll(\"circle\").attr(\"opacity\", 0.1);\n\n  // TODO: make color black for colored plot\n  // Highlight points whose labels match the substring\n  const COLORFUL = Object.entries(colorMap).length > 0 ? true : false;\n\n  d3.selectAll(\"circle\")\n    .filter(function (d) {\n      if (d[2] !== undefined) {\n        let lowerCaseLabel = d[2].toLowerCase();\n        return lowerCaseLabel.includes(substring);\n      } else {\n        return false;\n      }\n    }).transition().duration(200)\n    .attr(\"fill\", function (d) {\n      if (COLORFUL) {\n        return \"black\";\n      } else {\n        return \"orange\";\n      }\n    })\n    .attr(\"class\", \"matches-substring brushed\")\n    .attr(\"opacity\", globalOpacity);\n}\n\nfunction clearSelectedMatchingPoints() {\n  d3.selectAll(\".matches-substring\").transition().duration(200).attr(\"class\", \"brushed\");\n}\n\n\n\nexport {\n  drawProjection,\n  drawTestProjection,\n  checkPoints,\n  autocheckPoints,\n  reset,\n  clearSVG,\n  changeOpacity,\n  changeDotSize,\n  highlightLabel,\n  drawToolTip,\n  eraseToolTip,\n  getCentroid,\n  toggleDotDisplay,\n  findMatchingPoints,\n  clearSelectedMatchingPoints,\n};\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/index.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/reportWebVitals.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/App.js",["180"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/LeftPanel.js",["181","182","183","184","185","186","187","188","189","190","191","192","193","194"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/MouseDraw.js",["195","196"],[],"import React, {\n  useMemo,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n} from \"react\";\nimport * as d3 from \"d3\";\nimport {\n  checkPoints,\n  autocheckPoints,\n  reset,\n  drawToolTip,\n  eraseToolTip,\n} from \"../d3-rendering/projectionManipulationFunctions.js\";\nimport \"../App.css\";\nimport { RightPanel } from \"./RightPanel.js\";\nimport axios from \"axios\";\nimport { drawClouds } from \"../d3-rendering/cloudFunctions.js\";\n\nconst localDevURL = \"http://127.0.0.1:8000/\";\nconst DEFAULT_PROMPT =\n  \"What is the common theme between the selected sentences?\";\n\n// Line element\nconst Line = ({ points, drawing }) => {\n  const line = useMemo(() => {\n    return d3\n      .line()\n      .x((d) => d.x)\n      .y((d) => d.y);\n  }, []);\n\n  var dataCopy = points;\n  // console.log(points);\n\n  // Closes loop if done drawing\n  if (dataCopy.length > 0 && !drawing) {\n    dataCopy = [...dataCopy, points[0]];\n  }\n\n  return (\n    <path\n      id=\"lasso\"\n      d={line(dataCopy)}\n      style={{\n        stroke: \"black\",\n        strokeWidth: 3,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        fill: \"rgba(0,100,255,0.05)\",\n      }}\n    />\n  );\n};\n\n\n\nexport const MouseDraw = ({ x, y, width, height }) => {\n  // States and state setters\n  const [drawing, setDrawing] = useState(false);\n  const [currentLine, setCurrentLine] = useState({ points: [] });\n  const [selectedPoints, setSelectedPoints] = useState([]);\n  const [topWords, setTopWords] = useState({\n    positiveWord: null,\n    negativeWord: null,\n  });\n  const [wordsLoading, setWordsLoading] = useState(false);\n  const [keyVal, setKeyVal] = useState(\"\");\n  const [test_text, setTestText] = useState(\"\");\n\n  const [prompt, setPrompt] = useState(DEFAULT_PROMPT);\n  const [explanation, setExplanation] = useState(\n    \"Select points to see an explanation\"\n  );\n  const [autoClusterLabel, setautoClusterLabel] =  useState(false);\n\n\n\n  const drawingAreaRef = useRef();\n\n  // When the mouse moves, adds the newest point to the list of points for the current line\n  const mouseMove = useCallback(\n    function (event) {\n      const [x, y] = d3.pointer(event);\n      if (drawing) {\n        setCurrentLine((line) => ({\n          ...line,\n          points: [...line.points, { x, y }],\n        }));\n      }\n    },\n    [drawing]\n  );\n\n  // Creates a new line and starts drawing\n  function enableDrawing() {\n    reset();\n    setCurrentLine({ points: [] });\n    setSelectedPoints([]);\n    setDrawing(true);\n    setTopWords({ positiveWord: null, negativeWord: null });\n  }\n\n  // Adds the new line to the array of lines, stops drawing on mouseup\n  function disableDrawing() {\n    setDrawing(false);\n    // Check if points are in path on mouseup\n    let { brushedPoints, categorizedPoints, selectedLabels } = checkPoints();\n\n    // Send brushed points to right panel\n    setSelectedPoints(brushedPoints);\n    \n    if (brushedPoints.length > 0) {\n      // Send categorized points to back for linear classification\n      setWordsLoading(true);\n      axios\n        .post(localDevURL + \"categorize-data\", {\n          data: JSON.stringify(categorizedPoints),\n        })\n        .then((response) => {\n          console.log(\"Categorized!\", response.data.data);\n          let newTopWords = drawClouds(response.data.data);\n          setWordsLoading(false);\n          setTopWords(newTopWords);\n          // TODO: do things with response\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n      axios\n        .post(localDevURL + \"GPT-explanation\", {\n          apiKey: keyVal,\n          selectedLabels: JSON.stringify([prompt, ...selectedLabels]),\n        })\n        .then((response) => {\n          console.log(response)\n          setExplanation(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }\n\n  function getExplanationClusterLabel(){\n    console.log(autoClusterLabel)\n    setDrawing(false);\n    // Check if points are in path on mouseup\n    let { brushedPoints, categorizedPoints, selectedLabels } = autocheckPoints(autoClusterLabel);\n\n    // Send brushed points to right panel\n    setSelectedPoints(brushedPoints);\n    \n    if (brushedPoints.length > 0) {\n      // Send categorized points to back for linear classification\n      setWordsLoading(true);\n      axios\n        .post(localDevURL + \"categorize-data\", {\n          data: JSON.stringify(categorizedPoints),\n        })\n        .then((response) => {\n          console.log(\"Categorized!\", response.data.data);\n          let newTopWords = drawClouds(response.data.data);\n          setWordsLoading(false);\n          setTopWords(newTopWords);\n          // TODO: do things with response\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n      axios\n        .post(localDevURL + \"GPT-explanation\", {\n          apiKey: keyVal,\n          selectedLabels: JSON.stringify([prompt, ...selectedLabels]),\n        })\n        .then((response) => {\n          console.log(response)\n          setExplanation(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }\n\n \n\n  function handleMouseOver(e) {\n    if (!drawing && e.target.tagName.toLowerCase() === \"circle\") {\n      drawToolTip(e.target.id, width);\n    }\n  }\n\n  function handleMouseOut(e) {\n    if (!drawing && e.target.tagName.toLowerCase() === \"circle\") {\n      eraseToolTip(e.target.id);\n    }\n  }\n\n  // Called mouseMove on mouseover of the drawing area\n  useEffect(() => {\n    const area = d3.select(drawingAreaRef.current);\n    area.on(\"mousemove\", mouseMove);\n    return () => area.on(\"mousemove\", null);\n  }, [mouseMove]);\n\n\n\n\n  // request new explanation when prompt changes\n  useEffect(() => {\n    console.log(\"KEY:\", keyVal);\n    console.log(\"changedPrompt:\", prompt);\n    let { brushedPoints, categorizedPoints, selectedLabels } = checkPoints();\n    if (brushedPoints.length > 0) {\n      axios\n        .post(localDevURL + \"GPT-explanation\", {\n          apiKey: keyVal,\n          selectedLabels: JSON.stringify([prompt, ...selectedLabels]),\n        })\n        .then((response) => {\n          console.log(response);\n          setExplanation(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }, [prompt]);\n\n \n\n  return (\n    <div className=\"body\">\n      <svg\n        id=\"containerSVG\"\n        width={width}\n        height={height}\n        onMouseDown={enableDrawing}\n        onMouseUp={disableDrawing}\n        onMouseOver={(e) => {\n          handleMouseOver(e);\n        }}\n        onMouseOut={(e) => {\n          handleMouseOut(e);\n        }}\n      >\n        <g ref={drawingAreaRef}>\n          {/* Drawing background, gives \"g\" its size */}\n          <rect\n            x={0}\n            y={0}\n            width={width}\n            height={height}\n            style={{ fill: \"white\" }}\n          />\n          {/* Renders lines */}\n          <Line points={currentLine.points} drawing={drawing} />\n        </g>\n      </svg>\n      <RightPanel\n        selectedPoints={selectedPoints}\n        pathPoints={currentLine.points}\n        topWords={topWords}\n        wordsLoading={wordsLoading}\n        prompt={prompt}\n        setPrompt={setPrompt}\n        explanation={explanation}\n        keyVal={keyVal}\n        setKeyVal={setKeyVal}\n        test_text = {test_text }\n        setTestText={setTestText}\n        autoClusterLabel={autoClusterLabel}\n        setautoClusterLabel={setautoClusterLabel}\n        onautoClusterLabelchange = {getExplanationClusterLabel}\n      />\n    </div>\n  );\n};\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/Navbar.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/InfoTooltip.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/components/RightPanel.js",["197","198","199"],[],"import \"../App.css\";\nimport { useState, useEffect } from \"react\";\nimport Table from \"react-bootstrap/Table\";\nimport Form from \"react-bootstrap/Form\";\nimport Button from \"react-bootstrap/Button\";\nimport styled, { keyframes } from \"styled-components\";\nimport Slider from \"@mui/material/Slider\";\nimport axios from \"axios\";\n\n\n\n\nimport {\n  highlightLabel,\n  getCentroid,\n  findMatchingPoints,\n  clearSelectedMatchingPoints,\n  reset,\n  drawTestProjection,\n} from \"../d3-rendering/projectionManipulationFunctions.js\";\nimport { InfoTooltip } from \"./InfoTooltip.js\";\nimport { text } from \"d3\";\n\n\nconst localDevURL = \"http://127.0.0.1:8000/\";\n\nconst DEFAULT_PROMPT =\n  \"What is the common theme between the selected sentences?\";\n\n// Loading animation\nconst breatheAnimation = keyframes`\n 0% { opacity: 0.6; }\n 50% { opacity: 1; }\n 100% { opacity: 0.6; }`;\n\nconst PlaceholderImage = styled.img`\n  animation-name: ${breatheAnimation};\n  animation-duration: 1.5s;\n  animation-iteration-count: infinite;\n`;\n\nconst LabelSearch = () => {\n  const [substring, setSubstring] = useState(\"\");\n\n  const handleSubstringChange = (e) => {\n    setSubstring(e.target.value);\n  };\n\n  const enterSubmit = (e) => {\n    if (e.key === \"Enter\") {\n      handleSubmit();\n    }\n  };\n\n  const handleSubmit = () => {\n    clearSelectedMatchingPoints();\n    reset();\n    findMatchingPoints(substring);\n  };\n\n  const handleReset = () => {\n    clearSelectedMatchingPoints();\n    reset();\n  };\n\n  return (\n    <>\n      <Form.Group className=\"mb-3\" controlId=\"findSubstring\">\n          \n        <div className=\"button-box\">\n          <Form.Control\n            type=\"substring\"\n            size=\"sm\"\n            placeholder=\"Enter Keywords\"\n            onChange={handleSubstringChange}\n            onKeyPress={enterSubmit}\n          />\n          <Button\n            size=\"sm\"\n            variant=\"secondary\"\n            type=\"submit\"\n            onClick={handleSubmit}\n          >\n            Search\n          </Button>\n          <Button\n            size=\"sm\"\n            variant=\"outline-secondary\"\n            className=\"resetButton\"\n            onClick={handleReset}\n          >\n            reset\n          </Button>\n        </div>\n      </Form.Group>\n    </>\n  );\n};\n\n// Analysis panel for displaying info\nexport const RightPanel = ({\n  selectedPoints,\n  pathPoints,\n  topWords,\n  wordsLoading,\n  prompt,\n  setPrompt,\n  explanation,\n  keyVal,\n  setKeyVal,\n  test_text,\n  setTestText,\n  autoClusterLabel,\n  setautoClusterLabel,\n  onautoClusterLabelchange \n}) => {\n  const [selectedItems, setSelectedItems] = useState([]);\n  const [promptValue, setPromptValue] = useState(prompt);\n  const associatedWordsExplanation =\n    \"We run a linear classifier on points in the circled area versus points not in the circled area. We return the top 30 words that are positively and negatively associated with being in the circled area\";\n\n  // Generates table items if there are selected points\n  useEffect(() => {\n    if (selectedPoints.length > 0) {\n      let labelDict = {};\n\n      // Calculates centroid of lassoed area\n      console.log(pathPoints,selectedPoints)\n\n      let centroid = {x:0, y:0}\n\n      if (pathPoints.length != 0) {\n        let centroid = getCentroid(pathPoints);\n\n      }\n\n      for (let point of selectedPoints) {\n        // Creates ids for a table item, if there are multiple of the same label, this allows you to map from the table item to the labels\n        if (point.label in labelDict) {\n          labelDict[point.label].id =\n            labelDict[point.label].id + \" \" + point.id;\n        } else {\n          labelDict[point.label] = { id: point.id };\n        }\n\n        // Calculates distance from the centroid of the lassoed area to the point\n        labelDict[point.label].distFromCentroid = Math.sqrt(\n          (point.cx - centroid.x) ** 2 + (point.cy - centroid.y) ** 2\n        );\n      }\n\n      // Sorts labels by distance from the centroid\n      let labelsArray = Object.entries(labelDict);\n      labelsArray.sort(function (a, b) {\n        return a[1].distFromCentroid - b[1].distFromCentroid;\n      });\n\n      let newSelectedItems = [];\n      for (let [label, countInfo] of labelsArray) {\n        // Highlights top words in the label if topwords is populated\n        if (topWords.positiveWord !== null) {\n          let splitLabel = label.split(\" \");\n          for (let i = splitLabel.length - 1; i > -1; i--) {\n            let lowercaseCopy = splitLabel[i]\n              .toLowerCase()\n              .replace(/[.,/#!$?%^&*;:\"{}=\\-_`~()]/g, \"\");\n\n            switch (lowercaseCopy) {\n              case topWords.positiveWords[0]:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"positive-mark-1\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              case topWords.positiveWords[1]:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"positive-mark-2\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              case topWords.positiveWords[2]:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"positive-mark-3\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              case topWords.negativeWord:\n                splitLabel[i] = (\n                  <mark key={countInfo.id} className=\"negative-mark\">\n                    {splitLabel[i]}\n                  </mark>\n                );\n                break;\n              default:\n                break;\n            }\n\n            // Adds space\n            if (i === splitLabel.length - 1) {\n              continue;\n            } else {\n              splitLabel.splice(i + 1, 0, \" \");\n            }\n          }\n          label = splitLabel;\n          // console.log(\"newLabel\", lab el);\n        }\n        newSelectedItems.push(\n          <tr key={countInfo.id} onClick={(e) => highlightLabel(e)}>\n            <td>{newSelectedItems.length + 1}</td>\n            <td id={countInfo.id} className=\"label\">\n              {label}\n            </td>\n          </tr>\n        );\n      }\n\n      setSelectedItems(newSelectedItems);\n    } // Update selected items if selection is cleared\n    else if (selectedPoints.length === 0 && selectedItems.length > 0) {\n      setSelectedItems([]);\n    }\n  }, [selectedPoints, topWords, pathPoints, selectedItems.length]);\n\n  const handleNewPrompt = (e) => {\n    if (promptValue !== \"\") {\n      setPrompt(promptValue);\n    }\n\n    console.log(promptValue);\n\n    document.querySelector(\"#promptTextArea\").value = \"\";\n  };\n\n  const handleChangePrompt = (e) => {\n    setPromptValue(e.target.value);\n  };\n\n  \n\n  const handleChangeText = (e) => {\n    setTestText(e.target.value)\n};\n\nconst handleTextClick = (e) => {\n  axios\n    .post(localDevURL + \"test-projection\", {\n      text: test_text,\n      dataset: document.getElementById('dataset').textContent\n\n    })\n    .then((response) => {\n      drawTestProjection(response.data.data)\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n};\n\n  \n\n  const handleChangeKey = (e) => {\n    console.log(\"setting key value:\", e.target.value);\n    setKeyVal(e.target.value);\n  };\n\n  const handleChangeautoClusterLabel = (e) => {\n    console.log(\"setting clusterlabel value:\", e.target.value);\n    setautoClusterLabel(e.target.value);\n    onautoClusterLabelchange()\n  };\n  \n  const handleReset = () => {\n    setPrompt(DEFAULT_PROMPT);\n    document.querySelector(\"#promptTextArea\").value = \"\";\n  };\n\n\n  return (\n    \n    <div className=\"right panel\">\n      <LabelSearch />\n      <hr />\n      <div id=\"auto-explanation\">\n        <p className=\"title\">AutoCluster Explanation</p>\n        <div className=\"autoExplanationslider\">\n          <Slider\n            id=\"explanation-slider\"\n            aria-label=\"AutoCluster Label\"\n            value={autoClusterLabel}\n            valueLabelDisplay=\"auto\"\n            onChange={handleChangeautoClusterLabel}\n            step={1}\n            marks\n            min={1}\n            max={30}\n          />\n      </div></div>\n      <hr />\n      <div id=\"new-text\">\n      <p className=\"title\">Explanation by Example</p>\n\n      <Form.Control\n            className=\"form-control\"\n            id=\"TestProjectionArea\"\n            size=\"sm\"\n            as=\"textarea\"\n            placeholder={\"Enter Text Here to creat new projection point\"}\n            onChange={handleChangeText}\n          ></Form.Control>\n      <Button\n            size=\"sm\"\n            variant=\"secondary\"\n            type=\"submit\"\n            onClick={handleTextClick}>\n            Show\n          </Button>\n          </div>\n          <hr />\n\n      <div className=\"title\">\n        <p>Explanation as keywords</p>\n        <InfoTooltip text={associatedWordsExplanation} />\n      </div>\n      <div id=\"cloud-div\">\n        <div id=\"positive-cloud-div\">\n          {wordsLoading ? (\n            <PlaceholderImage\n              src=\"https://storage.googleapis.com/htw-website-uploads/Grey-placeholder-image2.jpg\"\n              className=\"placeholder-image\"\n              id=\"pos-placeholder\"\n            />\n          ) : null}\n        </div>\n      </div>\n      <hr />\n\n      <div id=\"natural-language-explanation\">\n        <p className=\"title\">Explanation by Interaction</p>\n        <Form.Group>\n          <Form.Control\n            className=\"form-control\"\n            size=\"sm\"\n            placeholder={keyVal === \"\" ? \"OpenAI Key\" : keyVal}\n            onChange={handleChangeKey}\n          ></Form.Control>\n          <Form.Control\n            className=\"form-control\"\n            id=\"promptTextArea\"\n            size=\"sm\"\n            as=\"textarea\"\n            rows={3}\n            placeholder={\"current prompt: \" + prompt}\n            onChange={handleChangePrompt}\n          ></Form.Control>\n          <div className=\"button-box\">\n            <Button\n              size=\"sm\"\n              variant=\"secondary\"\n              type=\"submit\"\n              onClick={handleNewPrompt}\n            >\n              Set Prompt\n            </Button>\n            <Button\n              size=\"sm\"\n              variant=\"outline-secondary\"\n              className=\"resetButton\"\n              onClick={handleReset}\n            >\n              Reset\n            </Button>\n          </div>\n        </Form.Group>\n        <Form.Control\n            className=\"form-control\"\n            id=\"explanation\"\n            size=\"sm\"\n            as=\"textarea\"\n            rows={3}\n            placeholder={explanation}\n            //onChange={handleChangePrompt}\n          ></Form.Control>\n      </div>\n      <hr />\n\n      <div id=\"unique-items-div\">\n        <p className=\"title\">\n          {selectedItems.length > 0\n            ? selectedItems.length + \" total unique\"\n            : 0}{\" \"}\n          items\n        </p>\n      </div>\n      <div className=\"tableDiv\">\n        <Table bordered>\n          <thead>\n            <tr>\n              <th>#</th>\n              <th>Item</th>\n            </tr>\n          </thead>\n          <tbody>{selectedItems}</tbody>\n        </Table>\n      </div>\n      <div className=\"footerSpacing\"></div>\n    </div>\n  );\n};\n\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/d3-rendering/projectionManipulationFunctions.js",["200","201"],[],"import * as d3 from \"d3\";\n\n// Storing state location data for quicker access\n/*\n  Schema:\n  database = {\n    id: {\n      cx: float\n      cy: float\n      label: string\n      originalColor: color\n    }\n  }\n  */\n\n// Global variables\nlet database = {}; // Database of projected points\nlet colorMap = {}; // Map of label --> color\nlet globalOpacity = 0.5; // Default opacity\nlet globalDotSize = 2; // Default dot size\nlet dataset = \"\"\n\n// Clears SVG in the center panel when new data is uploaded\nfunction clearSVG() {\n  var svg = d3.select(\"#containerSVG\");\n  svg.selectAll(\"circle\").remove(); // Removes plotted points\n  svg.selectAll(\"#lasso\").attr(\"d\", \"\"); // Resets lasso\n}\n\n// Function to draw projection, called once at render time and when new data is uploaded\n/*\n  Schema:\n  width = float\n  height = float\n  uploadedData = [x, y, label, color(if color column selected)]\n*/\nfunction drawProjection(width, height, uploadedData) {\n  let data = JSON.parse(JSON.stringify(uploadedData));\n  // Location var\n  const MARGIN = { top: 20, right: 0, bottom: 50, left: 85 },\n    SVG_X = width,\n    SVG_Y = height,\n    PLOT_X = SVG_X - MARGIN.right - MARGIN.left,\n    PLOT_Y = SVG_Y - MARGIN.top - MARGIN.bottom;\n\n  let x = d3.scaleLinear().range([MARGIN.left, PLOT_X]),\n    y = d3.scaleLinear().range([PLOT_Y, MARGIN.top]);\n\n\n    \n  // SVG\n  var svg = d3.select(\"#containerSVG\")//.call(d3.zoom().on(\"zoom\", function handleZoom(event) { svg.attr(\"transform\",event.transform) }));\n  //d3.select(\"#containerSVG\").on('mousedown.zoom',null);\n  // Re-setting database and colorMap and using uploaded data to draw when data has been loaded\n  database = {};\n  colorMap = {};\n\n  if (data[0].length === 5) {\n    makeColorMap(data);\n  }\n\n  var d_extent_x = d3.extent(data, (d) => +d[0]),\n    d_extent_y = d3.extent(data, (d) => +d[1]);\n\n  // Draw axes\n  x.domain(d_extent_x);\n  y.domain(d_extent_y);\n\n  // Generate IDs for points\n  for (let row of data) {\n    row.push(makeid(10));\n  }\n\n  // Draw circles\n  svg\n    .selectAll(\"circle\")\n    .data(data)\n    .enter()\n    .append(\"g\")\n    .append(\"circle\")\n    .attr(\"r\", globalDotSize)\n    .attr(\"opacity\", globalOpacity)\n    .attr(\"id\", (d) => {\n      let id = d[d.length - 1];\n      database[id] = { label: d[2], keyword:d[4]};\n      return id;\n    })\n    .attr(\"cx\", (d) => {\n      let centerX = x(+d[0]);\n      database[d[d.length - 1]].cx = centerX;\n      return centerX;\n    })\n    .attr(\"cy\", (d) => {\n      let centerY = y(+d[1]);\n      database[d[d.length - 1]].cy = centerY;\n      return centerY;\n    })\n    .attr(\"fill\", (d) => {\n      if (d.length === 6) {\n        return assignColor(d[3], d[5]);\n      } else {\n        database[d[d.length - 1]].originalColor = \"black\";\n        return \"black\";\n      }\n    })\n    .attr(\"class\", \"non-brushed\");\n  colorMap.x = x\n  colorMap.y = y\n  console.log(colorMap,x,y)\n  //svg.append(\"g\");\n  return colorMap;\n}\n\nfunction drawTestProjection(data) {\n  d3.select(\"#test_text\").remove();\n  var svg2 = d3.select(\"#containerSVG\").raise()\n  var x = colorMap.x \n  var y = colorMap.y\n  console.log(x,y)\n  let id = \"test_text\";\n  // Draw circles\n  svg2\n    .append(\"g\")\n    .selectAll(\"circle\")\n    .data(data)\n    .enter()\n    .append(\"circle\")\n    .attr(\"r\", 0)\n    .attr(\"opacity\", 1)\n    .attr(\"id\", id)\n    .attr(\"cx\", (d) => {\n      let centerX = x(+d[0]);\n      return centerX;\n    })\n    .attr(\"cy\", (d) => {\n      let centerY = y(+d[1]);\n      return centerY;\n    })\n    .attr(\"fill\", 'green').attr(\"class\", \"non-brushed\")\n    .transition().duration(200).attr(\"r\", 10)\n\n}\n\nfunction makeColorMap(data) {\n  let uniqueCategories = new Set();\n  let uniqueKeywords = new Set();\n\n  for (let item of data) {\n    \n    if (uniqueCategories.has(item[3])) {\n      continue;\n    } else {\n      uniqueCategories.add(item[3]);\n      uniqueKeywords.add(item[4]);\n    }\n  }\n  \n\n\n  let categoriesArray = Array.from(uniqueCategories);\n  let keywordsArray = Array.from(uniqueKeywords);\n  console.log(categoriesArray ,keywordsArray)\n  for (let i = 0; i < categoriesArray.length; i++) {\n    colorMap[categoriesArray[i]] = [COLORS[i % 11], keywordsArray[i]]  ;\n  }\n  \n}\n\nconst COLORS = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000'\n];\n\nfunction assignColor(category, id) {\n  database[id].category = category;\n  database[id].originalColor = colorMap[category][0];\n  return colorMap[category][0];\n}\n\n// Displays dots based on if the checkbox corresponding to their color is checked\nfunction toggleDotDisplay(checked, label) {\n  d3.selectAll(\"circle\")\n    .filter(function () {\n      if (database[d3.select(this).attr(\"id\")]) {\n        return database[d3.select(this).attr(\"id\")].category === +label;\n      } else {\n        return false;\n      }\n    }).transition().duration(200)\n    .attr(\"visibility\", function () {\n      if (checked) {\n        return \"visible\";\n      } else {\n        return \"hidden\";\n      }\n    })\n    .attr(\"opacity\", function () {\n      if (checked) {\n        return \"1\";\n      } else {\n        return \"0\";\n      }\n    });\n}\n\n// Check if points are within path on mouseup\nfunction checkPoints() {\n  var path = document.getElementById(\"lasso\");\n  let svg = document.getElementsByTagName(\"svg\")[0];\n  let brushedPoints = [];\n  let categorizedPoints = [];\n  let selectedLabels = [];\n  // d3.polygonContains(lassoPolygon, [x, y]);\n  for (let [id, idInfo] of Object.entries(database)) {\n    // Ignores point if it's not currently displayed\n    if (d3.select(\"#\" + id).attr(\"visibility\") === \"hidden\") {\n      continue;\n    }\n    const point = svg.createSVGPoint();\n\n    point.x = idInfo.cx;\n    point.y = idInfo.cy;\n    // Check if point is in path\n    if (path.isPointInFill(point)) {\n      idInfo.id = id;\n      brushedPoints.push(idInfo);\n      categorizedPoints.push([idInfo.label, 1]);\n      selectedLabels.push(idInfo.label);\n      // Change class and recolor points accordingly\n      let selector = \"#\" + id;\n      d3.selectAll(selector)\n        .attr(\"class\", function () {\n          const CURRENT_CLASS = d3.select(this).attr(\"class\");\n          if (CURRENT_CLASS.includes(\"brushed\")) {\n            return CURRENT_CLASS;\n          } else {\n            return \"brushed\";\n          }\n        })\n        .attr(\"fill\", (d, i, elements) => {\n          let color = database[id].originalColor;\n          if (d3.select(elements[i]).attr(\"class\").includes(\"brushed\")) {\n            if (Object.entries(colorMap).length > 0) {\n              color = \"black\"; \n              //color = \"red\"\n            } else {\n              color = \"orange\";\n            }\n          }\n\n          return color;\n        });\n    } else categorizedPoints.push([idInfo.label, 0]);\n  }\n\n  return {\n    brushedPoints: brushedPoints,\n    categorizedPoints: categorizedPoints,\n    selectedLabels: selectedLabels,\n  };\n}\n\nfunction autocheckPoints(label) {\n  console.log(\"in auto checkpoints\")\n  let brushedPoints = [];\n  let categorizedPoints = [];\n  let selectedLabels = [];\n  // d3.polygonContains(lassoPolygon, [x, y]);\n\n  for (let [id, idInfo] of Object.entries(database)) {\n    // Ignores point if it's not currently displayed\n    let selector = \"#\" + id;\n    if (database[id].category === +label) {\n      idInfo.id = id;\n      brushedPoints.push(idInfo);\n      categorizedPoints.push([idInfo.label, 1]);\n      selectedLabels.push(idInfo.label);\n\n      \n      d3.selectAll(selector).transition().duration(200)\n          .attr('r', 3*globalDotSize).attr(\"opacity\", 1)\n      \n    } else {categorizedPoints.push([idInfo.label, 0]);\n      d3.selectAll(selector).transition().duration(200)\n      .attr('r', globalDotSize).attr(\"opacity\", globalOpacity)}\n  }\n\n  return {\n    brushedPoints: brushedPoints,\n    categorizedPoints: categorizedPoints,\n    selectedLabels: selectedLabels,\n  };\n}\n// Reset projection to original state\nfunction reset() {\n  // Remove word clouds\n  d3.select(\"#positive-cloud\").remove();\n  d3.select(\"#negative-cloud\").remove();\n\n  // Re-color points\n  d3.selectAll(\"circle\")\n    .filter(function () {\n      if (d3.select(this).attr(\"class\").includes(\"matches-substring\")) {\n        return false;\n      } else {\n        return true;\n      }\n    })\n    .attr(\"class\", \"prev-brushed\").transition().duration(200)\n    //.attr(\"fill\", function () {\n    //  let color =\n    //    database[d3.select(this).attr(\"id\")] === undefined\n    //      ? \"black\"\n    //      : database[d3.select(this).attr(\"id\")].originalColor;\n    //  return color;\n    //})\n    .attr(\"r\", globalDotSize)\n    .attr(\"opacity\", globalOpacity);\n\n  // Remove point label\n  d3.selectAll(\".pointLabel\").transition().duration(200).remove();\n\n  // Reset lasso\n  d3.selectAll(\"#lasso\").transition().duration(200).attr(\"d\", \"\");\n}\n\n// Make random id strings\nfunction makeid(length) {\n  var result = \"\";\n  var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nfunction changeOpacity(opacity) {\n  d3.selectAll(\"circle\").attr(\"opacity\", opacity);\n  globalOpacity = opacity;\n}\nfunction changeDotSize(dotSize) {\n  d3.selectAll(\"circle\").attr(\"r\", dotSize);\n  globalDotSize = dotSize;\n}\n\nfunction changeDatset(name) {\n  dataset = name;\n}\n\nfunction highlightLabel(event) {\n  // Reset previously highlighted labels\n  d3.selectAll(\".brushed\").transition().duration(200)\n    .attr(\"fill\", \"orange\")\n    .attr(\"opacity\", globalOpacity)\n    .attr(\"class\", \"brushed\")\n    .attr(\"r\", globalDotSize);\n  let ids = event.target.id.split(\" \");\n\n  // Highlight labels corresponding to ids\n  for (let id of ids) {\n    d3.select(\"#\" + id).transition().duration(200)\n      .attr(\"fill\", \"green\")\n      .attr(\"class\", \"brushed selected\")\n      .attr(\"opacity\", globalOpacity + 0.5)\n      .attr(\"r\", globalDotSize*3);\n  }\n}\n\n// Draws tool tip for specific point on hover\nfunction drawToolTip(id, width) {\n  let pointInfo = database[id];\n  let svg = d3.select(\"#containerSVG\");\n  let toolTipWidth = 340;\n  let rectPadding = 1;\n  let hasCategory = database[id].originalColor !== \"black\" ? true : false;\n\n  // If dot is on right side of screen, flip tooltip\n  let leftflip = false;\n  if (pointInfo.cx > width / 2) {\n    leftflip = true;\n  }\n\n  // If dot is too high up, flip tooltip\n  let bottomflip = false;\n\n  // Draw tooltip of label text with rectangular border\n  // g element to hold the rect and text\n  var pointLabelContainer = svg\n    .append(\"g\")\n    .attr(\"transform\", \"translate(\" + pointInfo.cx + \",\" + pointInfo.cy + \")\")\n    .attr(\"class\", \"pointLabel\")\n    .attr(\"id\", id + \"label\");\n\n  // Text\n  let toytext = pointLabelContainer\n    .append(\"text\")\n    .text(\"item: \" + pointInfo.label)\n    .attr(\"x\", () => {\n      if (!leftflip) {\n        return rectPadding + \"em\";\n      } else {\n        return -toolTipWidth;\n      }\n    })\n    .attr(\"y\", -60 + rectPadding + 12)\n    .attr(\"id\", \"toyText\");\n\n  let lines = wrap(toytext, toolTipWidth - 2 * rectPadding);\n\n  d3.select(\"#toyText\").remove();\n\n  // Rect\n  let toolTipHeight = 1.1 * (lines + 1) + 1;\n\n  // Flips tooltip if it's too close to the top\n  if (pointInfo.cy < 100) {\n    bottomflip = true;\n  }\n\n  if (hasCategory) {\n    toolTipHeight = 1.1 * (lines + 4) + 1;\n  }\n\n  pointLabelContainer\n    .append(\"rect\")\n    .attr(\"x\", () => {\n      if (!leftflip) {\n        return 10;\n      } else {\n        return -(toolTipWidth + 10);\n      }\n    })\n    .attr(\"y\", () => {\n      if (!bottomflip) {\n        return -3 + \"em\";\n      } else {\n        return 0;\n      }\n    })\n    .attr(\"width\", toolTipWidth)\n    .attr(\"height\", toolTipHeight + \"em\")\n    .attr(\"fill\", \"white\")\n    .attr(\"stroke\", \"black\")\n    .attr(\"stroke-width\", \"1px\")\n    .style(\"z-index\", \"1\");\n\n  // Change fill/size of the corresponding point\n  d3.select(\"#\" + id)\n    .attr(\"fill\", \"green\")\n    .attr(\"opacity\", globalOpacity + 0.5)\n    .attr(\"r\", globalDotSize*3);\n\n  pointLabelContainer\n    .append(\"text\")\n    .text(\"item: \" + pointInfo.label)\n    .attr(\"x\", () => {\n      if (!leftflip) {\n        return rectPadding + \"em\";\n      } else {\n        return -toolTipWidth;\n      }\n    })\n    .attr(\"y\", () => {\n      if (!bottomflip) {\n        return -3 + rectPadding + 0.3 + \"em\";\n      } else {\n        return rectPadding + 0.3 + \"em\";\n      }\n    })\n    .style(\"z-index\", \"10\")\n    .attr(\"font-family\", \"Arial\")\n    .attr(\"fill\", \"black\")\n    .attr(\"stroke-width\", \"1px\")\n    .style(\"z-index\", \"10\")\n    .attr(\"vector-effect\", \"non-scaling-stroke\")\n    .call(wrap, toolTipWidth - 2 * 10);\n\n  // Add category information if has category\n  if (hasCategory) {\n    pointLabelContainer\n      .append(\"text\")\n      .text(\"category: \" + pointInfo.category)\n      .attr(\"x\", () => {\n        if (!leftflip) {\n          return rectPadding + \"em\";\n        } else {\n          return -toolTipWidth;\n        }\n      })\n      .attr(\"y\", () => {\n        if (!bottomflip) {\n          return -3 + toolTipHeight - 1.1 + \"em\";\n        } else {\n          return toolTipHeight - 1.1 + \"em\";\n        }\n      })\n      .style(\"z-index\", \"10\")\n      .attr(\"font-family\", \"Arial\")\n      .attr(\"fill\", \"black\")\n      .attr(\"stroke-width\", \"1px\")\n      .style(\"z-index\", \"10\")\n      .attr(\"vector-effect\", \"non-scaling-stroke\");\n  }\n}\n\n// Function for wrapping svg text elements\nfunction wrap(text, width) {\n  let lines = 0;\n  text.each(function () {\n    var text = d3.select(this),\n      words = text.text().split(/\\s+/).reverse(),\n      word,\n      line = [],\n      lineNumber = 0,\n      lineHeight = 1.1, // ems\n      x = text.attr(\"x\"),\n      y = text.attr(\"y\"),\n      dy = 0, //parseFloat(text.attr(\"dy\")),\n      tspan = text\n        .text(null)\n        .append(\"tspan\")\n        .attr(\"x\", x)\n        .attr(\"y\", y)\n        .attr(\"dy\", dy + \"em\");\n    while ((word = words.pop())) {\n      line.push(word);\n      tspan.text(line.join(\" \"));\n      if (tspan.node().getComputedTextLength() > width) {\n        line.pop();\n        tspan.text(line.join(\" \"));\n        line = [word];\n        tspan = text\n          .append(\"tspan\")\n          .attr(\"x\", x)\n          .attr(\"y\", y)\n          .attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\")\n          .text(word);\n      }\n    }\n    lines = lineNumber;\n  });\n\n  return lines;\n}\n\n// Uses the ID of a point to remove the corresponding tooltip on mouseOut\nfunction eraseToolTip(id) {\n  const POINT_CLASS_NAME = d3.select(\"#\" + id).attr(\"class\");\n\n  // Remove the tooltip\n  d3.select(\"#\" + id + \"label\").remove();\n\n  // Reset points to appropriate fill, opacity, and radius based on state\n  d3.select(\"#\" + id)\n    .attr(\"fill\", () => {\n      switch (POINT_CLASS_NAME) {\n        case \"brushed\":\n          return \"orange\";\n        case \"brushed selected\":\n          return \"green\";\n        case \"matches-substring brushed\":\n          return \"orange\";\n        default:\n          return database[id].originalColor; //////////******fix if the state is that it is currently selected, then stay black */\n          // return \"red\"\n      }\n    })\n    .attr(\"opacity\", () => {\n      switch (POINT_CLASS_NAME) {\n        case \"brushed\":\n          return globalOpacity;\n        case \"brushed selected\":\n          return globalOpacity + 0.5;\n        default:\n          return globalOpacity;\n      }\n    })\n    .attr(\"r\", () => {\n      switch (POINT_CLASS_NAME) {\n        case \"brushed\":\n          return globalDotSize*5;\n        case \"brushed selected\":\n          return globalDotSize*5;\n        default:\n          return globalDotSize;\n      }\n    });\n}\n\n// Gets centroid of set of points\nfunction getCentroid(points) {\n  var first = points[0],\n    last = points[points.length - 1];\n  if (first.x !== last.x || first.y !== last.y) points.push(first);\n  var twicearea = 0,\n    x = 0,\n    y = 0,\n    nPoints = points.length,\n    p1,\n    p2,\n    f;\n  for (var i = 0, j = nPoints - 1; i < nPoints; j = i++) {\n    p1 = points[i];\n    p2 = points[j];\n    f = p1.x * p2.y - p2.x * p1.y;\n    twicearea += f;\n    x += (p1.x + p2.x) * f;\n    y += (p1.y + p2.y) * f;\n  }\n  f = twicearea * 3;\n  return { x: x / f, y: y / f };\n}\n\nfunction findMatchingPoints(substring) {\n  substring = substring.toLowerCase();\n  // Changes opacity of dots to look like something's loading\n  // d3.selectAll(\"circle\").attr(\"opacity\", 0.1);\n\n  // TODO: make color black for colored plot\n  // Highlight points whose labels match the substring\n  const COLORFUL = Object.entries(colorMap).length > 0 ? true : false;\n\n  d3.selectAll(\"circle\")\n    .filter(function (d) {\n      if (d[2] !== undefined) {\n        let lowerCaseLabel = d[2].toLowerCase();\n        return lowerCaseLabel.includes(substring);\n      } else {\n        return false;\n      }\n    }).transition().duration(200)\n    .attr(\"fill\", function (d) {\n      if (COLORFUL) {\n        return \"black\";\n      } else {\n        return \"orange\";\n      }\n    })\n    .attr(\"class\", \"matches-substring brushed\")\n    .attr(\"opacity\", globalOpacity);\n}\n\nfunction clearSelectedMatchingPoints() {\n  d3.selectAll(\".matches-substring\").transition().duration(200).attr(\"class\", \"brushed\");\n}\n\n\n\nexport {\n  drawProjection,\n  drawTestProjection,\n  checkPoints,\n  autocheckPoints,\n  reset,\n  clearSVG,\n  changeOpacity,\n  changeDotSize,\n  highlightLabel,\n  drawToolTip,\n  eraseToolTip,\n  getCentroid,\n  toggleDotDisplay,\n  findMatchingPoints,\n  clearSelectedMatchingPoints,\n  changeDatset\n};\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/Text-Cluster-Explainer/frontend/src/d3-rendering/cloudFunctions.js",["202"],[],"import * as d3 from \"d3\";\nimport cloud from \"d3-cloud\";\n\nvar drawnClouds = false;\n\nfunction drawClouds(words) {\n  let factor = 1.1 / Math.sqrt(Math.max(words[0][1], Math.abs(words[0][3])));\n  // Removes previously drawn clouds\n  if (drawnClouds) {\n    d3.select(\"#positive-cloud\").remove();\n    d3.select(\"#negative-cloud\").remove();\n  } else {\n    drawnClouds = true;\n  }\n\n  // Removes placeholder images to get rid of jitter\n  // d3.select(\"#pos-placeholder\").remove();\n  // d3.select(\"#neg-placeholder\").remove();\n\n  var positiveLayout = cloud()\n    .size([400, 300])\n    .words(\n      words.map(function (d) {\n        return {\n          text: d[0],\n          size: Math.sqrt(Math.abs(d[1])) * factor * 20,\n        };\n      })\n    )\n    .padding(2)\n    .rotate(function () {\n      return 0;\n    })\n    .font(\"Helvetica\")\n    .fontSize(function (d) {\n      return d.size;\n    })\n    .on(\"end\", drawPositive);\n\n  positiveLayout.start();\n\n  function drawPositive(words) {\n    d3.select(\"#positive-cloud-div\")\n      .append(\"svg\")\n      .attr(\"id\", \"positive-cloud\")\n      .attr(\"width\", positiveLayout.size()[0])\n      .attr(\"height\", positiveLayout.size()[1])\n      .append(\"g\")\n      .attr(\n        \"transform\",\n        \"translate(\" +\n          positiveLayout.size()[0] / 2 +\n          \",\" +\n          positiveLayout.size()[1] / 2 +\n          \")\"\n      )\n      .selectAll(\"text\")\n      .data(words)\n      .enter()\n      .append(\"text\")\n      .style(\"font-size\", function (d) {\n        return d.size + \"px\";\n      })\n      .style(\"font-family\", \"Cambria\")\n      .style(\"font-weight\", function (d) {\n        {console.log(d.size*25);return d.size*25};\n      })\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"fill\", \"green\")\n      .attr(\"transform\", function (d) {\n        return \"translate(\" + [d.x, d.y] + \")rotate(\" + d.rotate + \")\";\n      })\n      .text(function (d) {\n        return d.text;\n      });\n  }\n\n  var negativeLayout = cloud()\n    .size([180, 300])\n    .words(\n      words.map(function (d) {\n        return {\n          text: d[2],\n          size: Math.sqrt(Math.abs(d[3])) * factor * 20,\n        };\n      })\n    )\n    .padding(2)\n    .rotate(function () {\n      return 0;\n    })\n    .font(\"Impact\")\n    .fontSize(function (d) {\n      return d.size;\n    })\n    .on(\"end\", drawNegative);\n\n  negativeLayout.start();\n\n  function drawNegative(words) {\n    d3.select(\"#negative-cloud-div\")\n      .append(\"svg\")\n      .attr(\"id\", \"negative-cloud\")\n      .attr(\"width\", negativeLayout.size()[0])\n      .attr(\"height\", negativeLayout.size()[1])\n      .append(\"g\")\n      .attr(\n        \"transform\",\n        \"translate(\" +\n          negativeLayout.size()[0] / 2 +\n          \",\" +\n          negativeLayout.size()[1] / 2 +\n          \")\"\n      )\n      .selectAll(\"text\")\n      .data(words)\n      .enter()\n      .append(\"text\")\n      .style(\"font-size\", function (d) {\n        return d.size + \"px\";\n      })\n      .style(\"font-family\", \"Helvetica\")\n      .style(\"font-weight\", 600)\n      .attr(\"fill\", \"red\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"transform\", function (d) {\n        return \"translate(\" + [d.x, d.y] + \")rotate(\" + d.rotate + \")\";\n      })\n      .text(function (d) {\n        return d.text;\n      });\n  }\n\n  return {\n    positiveWords: [words[0][0], words[1][0], words[2][0]],\n    negativeWords: words[0][2],\n  };\n}\n\nexport { drawClouds };\n","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/index.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/App.js",["203"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/reportWebVitals.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/Navbar.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/MouseDraw.js",["204","205"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/LeftPanel.js",["206","207","208","209","210","211","212","213","214","215","216","217","218","219"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/InfoTooltip.js",[],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/components/RightPanel.js",["220","221","222"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/d3-rendering/cloudFunctions.js",["223"],[],"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/FlaskReactHeroku/frontend/src/d3-rendering/projectionManipulationFunctions.js",["224","225"],[],{"ruleId":"226","severity":1,"message":"227","line":7,"column":10,"nodeType":"228","messageId":"229","endLine":7,"endColumn":16},{"ruleId":"230","severity":1,"message":"231","line":242,"column":4,"nodeType":"232","endLine":242,"endColumn":12,"suggestions":"233"},{"ruleId":"226","severity":1,"message":"234","line":250,"column":26,"nodeType":"228","messageId":"229","endLine":250,"endColumn":43},{"ruleId":"230","severity":1,"message":"235","line":265,"column":6,"nodeType":"232","endLine":265,"endColumn":14,"suggestions":"236"},{"ruleId":"226","severity":1,"message":"237","line":6,"column":8,"nodeType":"228","messageId":"229","endLine":6,"endColumn":20},{"ruleId":"226","severity":1,"message":"238","line":22,"column":10,"nodeType":"228","messageId":"229","endLine":22,"endColumn":21},{"ruleId":"226","severity":1,"message":"239","line":41,"column":7,"nodeType":"228","messageId":"229","endLine":41,"endColumn":13},{"ruleId":"226","severity":1,"message":"240","line":88,"column":10,"nodeType":"228","messageId":"229","endLine":88,"endColumn":22},{"ruleId":"226","severity":1,"message":"241","line":88,"column":24,"nodeType":"228","messageId":"229","endLine":88,"endColumn":39},{"ruleId":"226","severity":1,"message":"242","line":123,"column":10,"nodeType":"228","messageId":"229","endLine":123,"endColumn":21},{"ruleId":"226","severity":1,"message":"243","line":123,"column":23,"nodeType":"228","messageId":"229","endLine":123,"endColumn":37},{"ruleId":"226","severity":1,"message":"244","line":168,"column":9,"nodeType":"228","messageId":"229","endLine":168,"endColumn":38},{"ruleId":"226","severity":1,"message":"245","line":22,"column":10,"nodeType":"228","messageId":"229","endLine":22,"endColumn":14},{"ruleId":"246","severity":1,"message":"247","line":132,"column":29,"nodeType":"248","messageId":"249","endLine":132,"endColumn":31},{"ruleId":"226","severity":1,"message":"250","line":133,"column":13,"nodeType":"228","messageId":"229","endLine":133,"endColumn":21},{"ruleId":"251","severity":1,"message":"252","line":66,"column":9,"nodeType":"253","messageId":"254","endLine":66,"endColumn":50},{"ruleId":"255","severity":1,"message":"256","line":243,"column":23,"nodeType":"257","messageId":"258","endLine":255,"endColumn":10},{"ruleId":"226","severity":1,"message":"227","line":7,"column":10,"nodeType":"228","messageId":"229","endLine":7,"endColumn":16},{"ruleId":"226","severity":1,"message":"259","line":1,"column":8,"nodeType":"228","messageId":"229","endLine":1,"endColumn":17},{"ruleId":"226","severity":1,"message":"260","line":2,"column":8,"nodeType":"228","messageId":"229","endLine":2,"endColumn":14},{"ruleId":"226","severity":1,"message":"237","line":6,"column":8,"nodeType":"228","messageId":"229","endLine":6,"endColumn":20},{"ruleId":"226","severity":1,"message":"238","line":24,"column":10,"nodeType":"228","messageId":"229","endLine":24,"endColumn":21},{"ruleId":"226","severity":1,"message":"240","line":83,"column":10,"nodeType":"228","messageId":"229","endLine":83,"endColumn":22},{"ruleId":"226","severity":1,"message":"241","line":83,"column":24,"nodeType":"228","messageId":"229","endLine":83,"endColumn":39},{"ruleId":"226","severity":1,"message":"242","line":123,"column":10,"nodeType":"228","messageId":"229","endLine":123,"endColumn":21},{"ruleId":"226","severity":1,"message":"243","line":123,"column":23,"nodeType":"228","messageId":"229","endLine":123,"endColumn":37},{"ruleId":"261","severity":1,"message":"262","line":148,"column":32,"nodeType":"257","messageId":"263","endLine":148,"endColumn":34},{"ruleId":"246","severity":1,"message":"247","line":149,"column":26,"nodeType":"248","messageId":"249","endLine":149,"endColumn":28},{"ruleId":"246","severity":1,"message":"247","line":149,"column":45,"nodeType":"248","messageId":"249","endLine":149,"endColumn":47},{"ruleId":"226","severity":1,"message":"244","line":172,"column":9,"nodeType":"228","messageId":"229","endLine":172,"endColumn":38},{"ruleId":"246","severity":1,"message":"264","line":202,"column":13,"nodeType":"248","messageId":"249","endLine":202,"endColumn":15},{"ruleId":"246","severity":1,"message":"264","line":206,"column":13,"nodeType":"248","messageId":"249","endLine":206,"endColumn":15},{"ruleId":"226","severity":1,"message":"234","line":215,"column":26,"nodeType":"228","messageId":"229","endLine":215,"endColumn":43},{"ruleId":"230","severity":1,"message":"235","line":230,"column":6,"nodeType":"232","endLine":230,"endColumn":14,"suggestions":"265"},{"ruleId":"226","severity":1,"message":"245","line":22,"column":10,"nodeType":"228","messageId":"229","endLine":22,"endColumn":14},{"ruleId":"246","severity":1,"message":"247","line":132,"column":29,"nodeType":"248","messageId":"249","endLine":132,"endColumn":31},{"ruleId":"226","severity":1,"message":"250","line":133,"column":13,"nodeType":"228","messageId":"229","endLine":133,"endColumn":21},{"ruleId":"226","severity":1,"message":"266","line":21,"column":5,"nodeType":"228","messageId":"229","endLine":21,"endColumn":12},{"ruleId":"255","severity":1,"message":"256","line":238,"column":23,"nodeType":"257","messageId":"258","endLine":250,"endColumn":10},{"ruleId":"251","severity":1,"message":"252","line":66,"column":9,"nodeType":"253","messageId":"254","endLine":66,"endColumn":50},{"ruleId":"226","severity":1,"message":"227","line":7,"column":10,"nodeType":"228","messageId":"229","endLine":7,"endColumn":16},{"ruleId":"226","severity":1,"message":"234","line":215,"column":26,"nodeType":"228","messageId":"229","endLine":215,"endColumn":43},{"ruleId":"230","severity":1,"message":"235","line":230,"column":6,"nodeType":"232","endLine":230,"endColumn":14,"suggestions":"267"},{"ruleId":"226","severity":1,"message":"259","line":1,"column":8,"nodeType":"228","messageId":"229","endLine":1,"endColumn":17},{"ruleId":"226","severity":1,"message":"260","line":2,"column":8,"nodeType":"228","messageId":"229","endLine":2,"endColumn":14},{"ruleId":"226","severity":1,"message":"237","line":6,"column":8,"nodeType":"228","messageId":"229","endLine":6,"endColumn":20},{"ruleId":"226","severity":1,"message":"238","line":24,"column":10,"nodeType":"228","messageId":"229","endLine":24,"endColumn":21},{"ruleId":"226","severity":1,"message":"240","line":83,"column":10,"nodeType":"228","messageId":"229","endLine":83,"endColumn":22},{"ruleId":"226","severity":1,"message":"241","line":83,"column":24,"nodeType":"228","messageId":"229","endLine":83,"endColumn":39},{"ruleId":"226","severity":1,"message":"242","line":123,"column":10,"nodeType":"228","messageId":"229","endLine":123,"endColumn":21},{"ruleId":"226","severity":1,"message":"243","line":123,"column":23,"nodeType":"228","messageId":"229","endLine":123,"endColumn":37},{"ruleId":"261","severity":1,"message":"262","line":148,"column":32,"nodeType":"257","messageId":"263","endLine":148,"endColumn":34},{"ruleId":"246","severity":1,"message":"247","line":149,"column":26,"nodeType":"248","messageId":"249","endLine":149,"endColumn":28},{"ruleId":"246","severity":1,"message":"247","line":149,"column":45,"nodeType":"248","messageId":"249","endLine":149,"endColumn":47},{"ruleId":"226","severity":1,"message":"244","line":172,"column":9,"nodeType":"228","messageId":"229","endLine":172,"endColumn":38},{"ruleId":"246","severity":1,"message":"264","line":202,"column":13,"nodeType":"248","messageId":"249","endLine":202,"endColumn":15},{"ruleId":"246","severity":1,"message":"264","line":206,"column":13,"nodeType":"248","messageId":"249","endLine":206,"endColumn":15},{"ruleId":"226","severity":1,"message":"245","line":22,"column":10,"nodeType":"228","messageId":"229","endLine":22,"endColumn":14},{"ruleId":"246","severity":1,"message":"247","line":132,"column":29,"nodeType":"248","messageId":"249","endLine":132,"endColumn":31},{"ruleId":"226","severity":1,"message":"250","line":133,"column":13,"nodeType":"228","messageId":"229","endLine":133,"endColumn":21},{"ruleId":"251","severity":1,"message":"252","line":66,"column":9,"nodeType":"253","messageId":"254","endLine":66,"endColumn":50},{"ruleId":"226","severity":1,"message":"266","line":21,"column":5,"nodeType":"228","messageId":"229","endLine":21,"endColumn":12},{"ruleId":"255","severity":1,"message":"256","line":238,"column":23,"nodeType":"257","messageId":"258","endLine":250,"endColumn":10},"no-unused-vars","'Header' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'test_text', 'x', and 'y'. Either include them or remove the dependency array. If 'x' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["268"],"'categorizedPoints' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'keyVal'. Either include it or remove the dependency array.",["269"],"'ToggleButton' is defined but never used.","'InfoTooltip' is defined but never used.","'Header' is assigned a value but never used.","'checkedlabel' is assigned a value but never used.","'setCheckedLabel' is assigned a value but never used.","'clusterMode' is assigned a value but never used.","'setClusterMode' is assigned a value but never used.","'previousProjectionExplanation' is assigned a value but never used.","'text' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'centroid' is assigned a value but never used.","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'database', 'colorMap'.","ArrowFunctionExpression","unsafeRefs","'Container' is defined but never used.","'Navbar' is defined but never used.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","expectedAtEnd","Expected '===' and instead saw '=='.",["270"],"'dataset' is assigned a value but never used.",["271"],{"desc":"272","fix":"273"},{"desc":"274","fix":"275"},{"desc":"274","fix":"276"},{"desc":"274","fix":"277"},"Update the dependencies array to be: [prompt, test_text, x, y]",{"range":"278","text":"279"},"Update the dependencies array to be: [keyVal, prompt]",{"range":"280","text":"281"},{"range":"282","text":"281"},{"range":"283","text":"281"},[6409,6417],"[prompt, test_text, x, y]",[7049,7057],"[keyVal, prompt]",[6255,6263],[6272,6280]]